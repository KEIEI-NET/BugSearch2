# Phase 5 å®Ÿè£…è¨ˆç”»: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è§£æã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

*ãƒãƒ¼ã‚¸ãƒ§ãƒ³: v4.6.0 (Phase 5.0é–‹å§‹)*
*ä½œæˆæ—¥: 2025å¹´10æœˆ12æ—¥ JST*
*æœ€çµ‚æ›´æ–°: 2025å¹´10æœˆ12æ—¥ JST*

## ğŸ¯ Phase 5ã®ç›®æ¨™

**ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è§£æã¨IDEçµ±åˆã®å®Ÿè£…**

Phase 4ã§å®Œæˆã—ãŸã‚«ã‚¹ã‚¿ãƒ ãƒ«ãƒ¼ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ä¸Šã«ã€é–‹ç™ºè€…ãŒã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä¸­ã«ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’å¾—ã‚‰ã‚Œã‚‹ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚

### é”æˆåŸºæº–
- [ ] ãƒ•ã‚¡ã‚¤ãƒ«ã‚¦ã‚©ãƒƒãƒãƒ£ãƒ¼æ©Ÿèƒ½ã®å®Ÿè£…
- [ ] å·®åˆ†è§£æã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆå¤‰æ›´ç®‡æ‰€ã®ã¿è§£æï¼‰
- [ ] VS Codeæ‹¡å¼µã®åŸºç›¤å®Ÿè£…
- [ ] ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
- [ ] @perfectå“è³ªç¶­æŒ (å…¨ãƒ†ã‚¹ãƒˆ100%åˆæ ¼)

---

## ğŸ“Š ç¾åœ¨ã®çŠ¶æ³

### Phase 4.2å®Œäº† (v4.5.0) âœ…
- âœ… ãƒ«ãƒ¼ãƒ«å…±æœ‰ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…
- âœ… ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†æ©Ÿèƒ½
- âœ… AIæ”¯æ´ãƒ«ãƒ¼ãƒ«ç”Ÿæˆ
- âœ… å…¨ãƒ†ã‚¹ãƒˆ100%åˆæ ¼ (16/16)

### Phase 5.0ã®æ–°æ©Ÿèƒ½
Phase 4ã§å®Ÿè£…ã—ãŸæ©Ÿèƒ½ã‚’æ‹¡å¼µã—ã€ä»¥ä¸‹ã‚’å®Ÿç¾ï¼š

1. **ãƒ•ã‚¡ã‚¤ãƒ«ã‚¦ã‚©ãƒƒãƒãƒ£ãƒ¼**
   - ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´ã®è‡ªå‹•æ¤œå‡º
   - ä¿å­˜æ™‚ã®è‡ªå‹•è§£æãƒˆãƒªã‚¬ãƒ¼
   - å·®åˆ†æ¤œå‡ºï¼ˆå¤‰æ›´è¡Œã®ã¿è§£æï¼‰

2. **å·®åˆ†è§£æã‚¨ãƒ³ã‚¸ãƒ³**
   - Git diffã¨ã®çµ±åˆ
   - å¤‰æ›´ç®‡æ‰€ã®ç‰¹å®š
   - å¢—åˆ†ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ›´æ–°

3. **IDEçµ±åˆåŸºç›¤**
   - VS Codeæ‹¡å¼µã®åŸºæœ¬æ§‹é€ 
   - Language Server Protocolå¯¾å¿œ
   - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¨ºæ–­è¡¨ç¤º

4. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–**
   - ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰è§£æ
   - ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†
   - ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥

---

## ğŸ”§ å®Ÿè£…é …ç›®

### 1. ãƒ•ã‚¡ã‚¤ãƒ«ã‚¦ã‚©ãƒƒãƒãƒ£ãƒ¼æ©Ÿèƒ½ (å„ªå…ˆåº¦: é«˜)

#### core/file_watcher.py

```python
"""
ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ 

watchdogãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®å¤‰æ›´ã‚’ç›£è¦–
"""

from pathlib import Path
from typing import Callable, List, Optional, Set
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler, FileModifiedEvent
import time
import threading
from datetime import datetime, timedelta

class CodeFileHandler(FileSystemEventHandler):
    """
    ã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã®å¤‰æ›´ã‚’ç›£è¦–ã™ã‚‹ãƒãƒ³ãƒ‰ãƒ©ãƒ¼

    å¯¾å¿œæ‹¡å¼µå­:
    - .cs, .java, .php, .js, .ts, .tsx, .py, .go
    """

    SUPPORTED_EXTENSIONS = {
        '.cs', '.java', '.php', '.js', '.ts', '.tsx', '.py', '.go',
        '.c', '.cpp', '.h', '.hpp'
    }

    def __init__(
        self,
        on_file_changed: Callable[[Path], None],
        debounce_seconds: float = 1.0
    ):
        """
        åˆæœŸåŒ–

        Args:
            on_file_changed: ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
            debounce_seconds: ãƒ‡ãƒã‚¦ãƒ³ã‚¹æ™‚é–“ï¼ˆç§’ï¼‰
        """
        super().__init__()
        self.on_file_changed = on_file_changed
        self.debounce_seconds = debounce_seconds
        self._pending_files: Dict[Path, datetime] = {}
        self._lock = threading.Lock()
        self._debounce_thread: Optional[threading.Thread] = None
        self._stop_debounce = False

    def on_modified(self, event):
        """ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼"""
        if event.is_directory:
            return

        file_path = Path(event.src_path)

        # ã‚µãƒãƒ¼ãƒˆå¯¾è±¡ã®æ‹¡å¼µå­ã®ã¿å‡¦ç†
        if file_path.suffix not in self.SUPPORTED_EXTENSIONS:
            return

        # ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†
        with self._lock:
            self._pending_files[file_path] = datetime.now()

        # ãƒ‡ãƒã‚¦ãƒ³ã‚¹ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’èµ·å‹•ï¼ˆã¾ã å‹•ã„ã¦ã„ãªã„å ´åˆï¼‰
        if self._debounce_thread is None or not self._debounce_thread.is_alive():
            self._debounce_thread = threading.Thread(
                target=self._process_pending_files,
                daemon=True
            )
            self._debounce_thread.start()

    def _process_pending_files(self):
        """ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†: ä¸€å®šæ™‚é–“å¤‰æ›´ãŒãªã„ãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿å‡¦ç†"""
        while not self._stop_debounce:
            time.sleep(0.5)

            with self._lock:
                now = datetime.now()
                files_to_process = []

                for file_path, last_modified in list(self._pending_files.items()):
                    time_since_modified = (now - last_modified).total_seconds()

                    if time_since_modified >= self.debounce_seconds:
                        files_to_process.append(file_path)
                        del self._pending_files[file_path]

                if not self._pending_files:
                    # å‡¦ç†å¾…ã¡ãƒ•ã‚¡ã‚¤ãƒ«ãŒãªããªã£ãŸã‚‰ã‚¹ãƒ¬ãƒƒãƒ‰çµ‚äº†
                    break

            # ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œï¼ˆãƒ­ãƒƒã‚¯å¤–ã§ï¼‰
            for file_path in files_to_process:
                try:
                    self.on_file_changed(file_path)
                except Exception as e:
                    print(f"[ERROR] ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¨ãƒ©ãƒ¼ {file_path}: {e}")

    def stop(self):
        """ãƒ‡ãƒã‚¦ãƒ³ã‚¹ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’åœæ­¢"""
        self._stop_debounce = True
        if self._debounce_thread and self._debounce_thread.is_alive():
            self._debounce_thread.join(timeout=5)


class FileWatcher:
    """
    ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ 

    ä½¿ç”¨ä¾‹:
        watcher = FileWatcher(
            watch_paths=[Path("./src")],
            on_file_changed=analyze_file
        )
        watcher.start()
        # ... ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
        watcher.stop()
    """

    def __init__(
        self,
        watch_paths: List[Path],
        on_file_changed: Callable[[Path], None],
        debounce_seconds: float = 1.0
    ):
        """
        åˆæœŸåŒ–

        Args:
            watch_paths: ç›£è¦–å¯¾è±¡ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒªã‚¹ãƒˆ
            on_file_changed: ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
            debounce_seconds: ãƒ‡ãƒã‚¦ãƒ³ã‚¹æ™‚é–“
        """
        self.watch_paths = watch_paths
        self.on_file_changed = on_file_changed
        self.debounce_seconds = debounce_seconds

        self.observer = Observer()
        self.handler = CodeFileHandler(
            on_file_changed=on_file_changed,
            debounce_seconds=debounce_seconds
        )
        self._is_running = False

    def start(self):
        """ãƒ•ã‚¡ã‚¤ãƒ«ç›£è¦–ã‚’é–‹å§‹"""
        if self._is_running:
            print("[WARNING] ãƒ•ã‚¡ã‚¤ãƒ«ã‚¦ã‚©ãƒƒãƒãƒ£ãƒ¼ã¯æ—¢ã«å®Ÿè¡Œä¸­ã§ã™")
            return

        for watch_path in self.watch_paths:
            if not watch_path.exists():
                print(f"[WARNING] ç›£è¦–ãƒ‘ã‚¹ãŒå­˜åœ¨ã—ã¾ã›ã‚“: {watch_path}")
                continue

            self.observer.schedule(
                self.handler,
                str(watch_path),
                recursive=True
            )
            print(f"[INFO] ãƒ•ã‚¡ã‚¤ãƒ«ç›£è¦–é–‹å§‹: {watch_path}")

        self.observer.start()
        self._is_running = True
        print("[OK] ãƒ•ã‚¡ã‚¤ãƒ«ã‚¦ã‚©ãƒƒãƒãƒ£ãƒ¼èµ·å‹•å®Œäº†")

    def stop(self):
        """ãƒ•ã‚¡ã‚¤ãƒ«ç›£è¦–ã‚’åœæ­¢"""
        if not self._is_running:
            return

        self.handler.stop()
        self.observer.stop()
        self.observer.join(timeout=10)
        self._is_running = False
        print("[OK] ãƒ•ã‚¡ã‚¤ãƒ«ã‚¦ã‚©ãƒƒãƒãƒ£ãƒ¼åœæ­¢")

    def is_running(self) -> bool:
        """å®Ÿè¡Œä¸­ã‹ã©ã†ã‹"""
        return self._is_running
```

### 2. å·®åˆ†è§£æã‚¨ãƒ³ã‚¸ãƒ³ (å„ªå…ˆåº¦: é«˜)

#### core/incremental_analyzer.py

```python
"""
å·®åˆ†è§£æã‚¨ãƒ³ã‚¸ãƒ³

å¤‰æ›´ç®‡æ‰€ã®ã¿ã‚’è§£æã™ã‚‹ã“ã¨ã§é«˜é€ŸåŒ–ã‚’å®Ÿç¾
"""

from pathlib import Path
from typing import List, Dict, Optional, Set, Tuple
from dataclasses import dataclass
import subprocess
import json


@dataclass
class FileDiff:
    """ãƒ•ã‚¡ã‚¤ãƒ«å·®åˆ†æƒ…å ±"""
    file_path: Path
    added_lines: List[int]  # è¿½åŠ ã•ã‚ŒãŸè¡Œç•ªå·
    modified_lines: List[int]  # å¤‰æ›´ã•ã‚ŒãŸè¡Œç•ªå·
    deleted_lines: List[int]  # å‰Šé™¤ã•ã‚ŒãŸè¡Œç•ªå·
    total_changes: int  # ç·å¤‰æ›´è¡Œæ•°

    @property
    def changed_lines(self) -> Set[int]:
        """å¤‰æ›´ã•ã‚ŒãŸå…¨è¡Œç•ªå·"""
        return set(self.added_lines + self.modified_lines)


class IncrementalAnalyzer:
    """
    å·®åˆ†è§£æã‚¨ãƒ³ã‚¸ãƒ³

    Git diffã‚’åˆ©ç”¨ã—ã¦å¤‰æ›´ç®‡æ‰€ã®ã¿ã‚’è§£æ
    """

    def __init__(self, project_root: Path):
        """
        åˆæœŸåŒ–

        Args:
            project_root: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        """
        self.project_root = project_root
        self._last_commit_cache: Dict[Path, str] = {}

    def get_file_diff(self, file_path: Path) -> Optional[FileDiff]:
        """
        ãƒ•ã‚¡ã‚¤ãƒ«ã®å·®åˆ†æƒ…å ±ã‚’å–å¾—

        Args:
            file_path: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹

        Returns:
            å·®åˆ†æƒ…å ±ï¼ˆå¤‰æ›´ãŒãªã„å ´åˆã¯Noneï¼‰
        """
        try:
            # Git diffã‚’å®Ÿè¡Œ
            result = subprocess.run(
                [
                    'git', 'diff',
                    '--unified=0',  # ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆè¡Œãªã—
                    'HEAD',
                    str(file_path)
                ],
                cwd=self.project_root,
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode != 0:
                # Gitãƒªãƒã‚¸ãƒˆãƒªã§ãªã„ã€ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ãŒæœªè¿½è·¡
                return None

            if not result.stdout:
                # å¤‰æ›´ãªã—
                return None

            # å·®åˆ†ã‚’ãƒ‘ãƒ¼ã‚¹
            added_lines = []
            modified_lines = []
            deleted_lines = []

            for line in result.stdout.split('\n'):
                if line.startswith('@@'):
                    # @@ -1,3 +1,4 @@ ã®ã‚ˆã†ãªè¡Œã‚’ãƒ‘ãƒ¼ã‚¹
                    parts = line.split('@@')[1].strip().split()
                    if len(parts) >= 2:
                        # +1,4 ã®éƒ¨åˆ†ã‚’å–å¾—
                        new_range = parts[1].strip('+')
                        if ',' in new_range:
                            start, count = map(int, new_range.split(','))
                            for i in range(count):
                                added_lines.append(start + i)

            return FileDiff(
                file_path=file_path,
                added_lines=added_lines,
                modified_lines=[],
                deleted_lines=[],
                total_changes=len(added_lines)
            )

        except Exception as e:
            print(f"[ERROR] Git diffå–å¾—ã‚¨ãƒ©ãƒ¼ {file_path}: {e}")
            return None

    def analyze_changed_lines(
        self,
        file_path: Path,
        file_diff: FileDiff,
        rules: List
    ) -> List[Dict]:
        """
        å¤‰æ›´è¡Œã®ã¿ã‚’è§£æ

        Args:
            file_path: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
            file_diff: å·®åˆ†æƒ…å ±
            rules: é©ç”¨ã™ã‚‹ãƒ«ãƒ¼ãƒ«

        Returns:
            æ¤œå‡ºçµæœã®ãƒªã‚¹ãƒˆ
        """
        if not file_path.exists():
            return []

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
        except Exception as e:
            print(f"[ERROR] ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ {file_path}: {e}")
            return []

        detections = []
        changed_line_set = file_diff.changed_lines

        # å¤‰æ›´è¡Œã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯
        for line_num in changed_line_set:
            if line_num <= 0 or line_num > len(lines):
                continue

            line_content = lines[line_num - 1]

            # ãƒ«ãƒ¼ãƒ«é©ç”¨
            for rule in rules:
                if self._matches_rule(line_content, rule):
                    detections.append({
                        'rule_id': rule.id,
                        'line': line_num,
                        'severity': rule.base_severity,
                        'message': rule.name
                    })

        return detections

    def _matches_rule(self, line_content: str, rule) -> bool:
        """ãƒ«ãƒ¼ãƒ«ãƒãƒƒãƒãƒ³ã‚°ï¼ˆç°¡æ˜“ç‰ˆï¼‰"""
        import re

        # è¨€èªåˆ¤å®šã¯çœç•¥ï¼ˆå®Ÿéš›ã¯æ‹¡å¼µå­ã‹ã‚‰åˆ¤å®šï¼‰
        patterns = rule.patterns.get('csharp', [])

        for pattern_def in patterns:
            pattern = pattern_def.get('pattern', '')
            try:
                if re.search(pattern, line_content):
                    return True
            except re.error:
                continue

        return False

    def get_modified_files_since_last_analysis(self) -> List[Path]:
        """
        å‰å›ã®è§£æä»¥é™ã«å¤‰æ›´ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒªã‚¹ãƒˆã‚’å–å¾—

        Returns:
            å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒªã‚¹ãƒˆ
        """
        try:
            result = subprocess.run(
                ['git', 'diff', '--name-only', 'HEAD'],
                cwd=self.project_root,
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode != 0:
                return []

            files = []
            for line in result.stdout.strip().split('\n'):
                if line:
                    file_path = self.project_root / line
                    if file_path.exists():
                        files.append(file_path)

            return files

        except Exception as e:
            print(f"[ERROR] å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return []
```

### 3. VS Codeæ‹¡å¼µåŸºç›¤ (å„ªå…ˆåº¦: ä¸­)

#### vscode-extension/package.json

```json
{
  "name": "bugsearch2-vscode",
  "displayName": "BugSearch2",
  "description": "AI-powered code review with custom rules",
  "version": "0.1.0",
  "publisher": "bugsearch2",
  "engines": {
    "vscode": "^1.80.0"
  },
  "categories": [
    "Linters",
    "Programming Languages"
  ],
  "activationEvents": [
    "onLanguage:csharp",
    "onLanguage:java",
    "onLanguage:php",
    "onLanguage:javascript",
    "onLanguage:typescript",
    "onLanguage:python",
    "onLanguage:go"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "bugsearch2.analyzeFile",
        "title": "BugSearch2: Analyze Current File"
      },
      {
        "command": "bugsearch2.analyzeWorkspace",
        "title": "BugSearch2: Analyze Entire Workspace"
      }
    ],
    "configuration": {
      "type": "object",
      "title": "BugSearch2",
      "properties": {
        "bugsearch2.pythonPath": {
          "type": "string",
          "default": "python",
          "description": "Python executable path"
        },
        "bugsearch2.scriptPath": {
          "type": "string",
          "default": "",
          "description": "Path to codex_review_severity.py"
        },
        "bugsearch2.enableRealtime": {
          "type": "boolean",
          "default": true,
          "description": "Enable real-time analysis on file save"
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./"
  },
  "devDependencies": {
    "@types/vscode": "^1.80.0",
    "@types/node": "^18.x",
    "typescript": "^5.0.0"
  }
}
```

#### vscode-extension/src/extension.ts

```typescript
import * as vscode from 'vscode';
import { exec } from 'child_process';
import * as path from 'path';

let diagnosticCollection: vscode.DiagnosticCollection;
let analysisProcess: any = null;

export function activate(context: vscode.ExtensionContext) {
    console.log('BugSearch2 extension activated');

    diagnosticCollection = vscode.languages.createDiagnosticCollection('bugsearch2');
    context.subscriptions.push(diagnosticCollection);

    // ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜æ™‚ã®è‡ªå‹•è§£æ
    const config = vscode.workspace.getConfiguration('bugsearch2');
    if (config.get('enableRealtime', true)) {
        context.subscriptions.push(
            vscode.workspace.onDidSaveTextDocument(document => {
                analyzeDocument(document);
            })
        );
    }

    // ã‚³ãƒãƒ³ãƒ‰ç™»éŒ²
    context.subscriptions.push(
        vscode.commands.registerCommand('bugsearch2.analyzeFile', () => {
            const editor = vscode.window.activeTextEditor;
            if (editor) {
                analyzeDocument(editor.document);
            }
        })
    );

    context.subscriptions.push(
        vscode.commands.registerCommand('bugsearch2.analyzeWorkspace', () => {
            analyzeWorkspace();
        })
    );
}

function analyzeDocument(document: vscode.TextDocument) {
    const config = vscode.workspace.getConfiguration('bugsearch2');
    const pythonPath = config.get('pythonPath', 'python');
    const scriptPath = config.get('scriptPath', '');

    if (!scriptPath) {
        vscode.window.showErrorMessage(
            'BugSearch2: Please configure scriptPath in settings'
        );
        return;
    }

    const filePath = document.uri.fsPath;

    // Python ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œ
    const command = `${pythonPath} ${scriptPath} analyze-file "${filePath}"`;

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error('Analysis error:', error);
            return;
        }

        try {
            const result = JSON.parse(stdout);
            updateDiagnostics(document.uri, result);
        } catch (e) {
            console.error('Failed to parse analysis result:', e);
        }
    });
}

function updateDiagnostics(uri: vscode.Uri, result: any) {
    const diagnostics: vscode.Diagnostic[] = [];

    if (result.detections) {
        for (const detection of result.detections) {
            const line = detection.line - 1; // 0-based
            const range = new vscode.Range(line, 0, line, 999);

            const severity = detection.severity >= 8
                ? vscode.DiagnosticSeverity.Error
                : detection.severity >= 5
                ? vscode.DiagnosticSeverity.Warning
                : vscode.DiagnosticSeverity.Information;

            const diagnostic = new vscode.Diagnostic(
                range,
                `[${detection.rule_id}] ${detection.message}`,
                severity
            );
            diagnostic.source = 'BugSearch2';
            diagnostics.push(diagnostic);
        }
    }

    diagnosticCollection.set(uri, diagnostics);
}

function analyzeWorkspace() {
    vscode.window.showInformationMessage(
        'BugSearch2: Analyzing entire workspace...'
    );

    // TODO: ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹å…¨ä½“ã®è§£æå®Ÿè£…
}

export function deactivate() {
    if (diagnosticCollection) {
        diagnosticCollection.dispose();
    }
    if (analysisProcess) {
        analysisProcess.kill();
    }
}
```

### 4. ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è§£æCLI (å„ªå…ˆåº¦: é«˜)

#### watch_mode.py

```python
"""
ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è§£æãƒ¢ãƒ¼ãƒ‰

ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´ã‚’ç›£è¦–ã—ã€è‡ªå‹•è§£æã‚’å®Ÿè¡Œ
"""

import sys
from pathlib import Path
from typing import List
import argparse

sys.path.insert(0, str(Path(__file__).parent))

from core.file_watcher import FileWatcher
from core.incremental_analyzer import IncrementalAnalyzer
from core.rule_engine import load_all_rules


def analyze_file_incremental(file_path: Path, analyzer: IncrementalAnalyzer):
    """
    ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å·®åˆ†è§£æ

    Args:
        file_path: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
        analyzer: å·®åˆ†è§£æã‚¨ãƒ³ã‚¸ãƒ³
    """
    print(f"\n[ANALYZING] {file_path}")

    # å·®åˆ†å–å¾—
    file_diff = analyzer.get_file_diff(file_path)

    if file_diff is None:
        print(f"[INFO] å¤‰æ›´ãªã—: {file_path}")
        return

    if file_diff.total_changes == 0:
        print(f"[INFO] å¤‰æ›´ãªã—: {file_path}")
        return

    print(f"[INFO] å¤‰æ›´è¡Œæ•°: {file_diff.total_changes}è¡Œ")

    # ãƒ«ãƒ¼ãƒ«èª­ã¿è¾¼ã¿
    rules = load_all_rules()

    # å¤‰æ›´è¡Œã®ã¿è§£æ
    detections = analyzer.analyze_changed_lines(file_path, file_diff, rules)

    if not detections:
        print(f"[OK] å•é¡Œãªã—")
        return

    # æ¤œå‡ºçµæœè¡¨ç¤º
    print(f"\nğŸ”´ {len(detections)}ä»¶ã®å•é¡Œã‚’æ¤œå‡º:")
    for detection in detections:
        severity_icon = "ğŸ”´" if detection['severity'] >= 8 else "ğŸŸ¡"
        print(f"{severity_icon} è¡Œ{detection['line']}: [{detection['rule_id']}] {detection['message']}")


def watch_mode(watch_paths: List[Path], debounce_seconds: float = 1.0):
    """
    ã‚¦ã‚©ãƒƒãƒãƒ¢ãƒ¼ãƒ‰ã‚’é–‹å§‹

    Args:
        watch_paths: ç›£è¦–å¯¾è±¡ãƒ‘ã‚¹
        debounce_seconds: ãƒ‡ãƒã‚¦ãƒ³ã‚¹æ™‚é–“
    """
    print("=" * 80)
    print("ğŸ” BugSearch2 - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è§£æãƒ¢ãƒ¼ãƒ‰")
    print("=" * 80)
    print()
    print("ç›£è¦–å¯¾è±¡:")
    for path in watch_paths:
        print(f"  - {path}")
    print()
    print("Ctrl+C ã§çµ‚äº†")
    print("=" * 80)
    print()

    project_root = Path.cwd()
    analyzer = IncrementalAnalyzer(project_root)

    # ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
    def on_file_changed(file_path: Path):
        try:
            analyze_file_incremental(file_path, analyzer)
        except Exception as e:
            print(f"[ERROR] è§£æã‚¨ãƒ©ãƒ¼: {e}")

    # ãƒ•ã‚¡ã‚¤ãƒ«ã‚¦ã‚©ãƒƒãƒãƒ£ãƒ¼èµ·å‹•
    watcher = FileWatcher(
        watch_paths=watch_paths,
        on_file_changed=on_file_changed,
        debounce_seconds=debounce_seconds
    )

    try:
        watcher.start()

        # ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§å¾…æ©Ÿ
        import time
        while True:
            time.sleep(1)

    except KeyboardInterrupt:
        print("\n[INFO] çµ‚äº†ã—ã¾ã™...")
        watcher.stop()
    except Exception as e:
        print(f"\n[ERROR] äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: {e}")
        watcher.stop()


def main():
    """ãƒ¡ã‚¤ãƒ³é–¢æ•°"""
    parser = argparse.ArgumentParser(
        description='BugSearch2 ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è§£æãƒ¢ãƒ¼ãƒ‰'
    )
    parser.add_argument(
        'paths',
        nargs='*',
        default=['./src'],
        help='ç›£è¦–å¯¾è±¡ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: ./src)'
    )
    parser.add_argument(
        '--debounce',
        type=float,
        default=1.0,
        help='ãƒ‡ãƒã‚¦ãƒ³ã‚¹æ™‚é–“ï¼ˆç§’ï¼‰ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 1.0)'
    )

    args = parser.parse_args()

    watch_paths = [Path(p) for p in args.paths]

    # å­˜åœ¨ç¢ºèª
    for path in watch_paths:
        if not path.exists():
            print(f"[ERROR] ãƒ‘ã‚¹ãŒå­˜åœ¨ã—ã¾ã›ã‚“: {path}")
            return 1

    watch_mode(watch_paths, args.debounce)
    return 0


if __name__ == "__main__":
    sys.exit(main())
```

---

## ğŸ“‹ ãƒ†ã‚¹ãƒˆè¨ˆç”»

### test/test_phase5_realtime.py

```python
"""
Phase 5ãƒ†ã‚¹ãƒˆ: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è§£ææ©Ÿèƒ½

@perfectå“è³ªä¿è¨¼:
- ãƒ•ã‚¡ã‚¤ãƒ«ã‚¦ã‚©ãƒƒãƒãƒ£ãƒ¼æ©Ÿèƒ½
- å·®åˆ†è§£æã‚¨ãƒ³ã‚¸ãƒ³
- ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
"""

import unittest
from pathlib import Path
import time
import shutil
from core.file_watcher import FileWatcher, CodeFileHandler
from core.incremental_analyzer import IncrementalAnalyzer, FileDiff


class TestFileWatcher(unittest.TestCase):
    """ãƒ•ã‚¡ã‚¤ãƒ«ã‚¦ã‚©ãƒƒãƒãƒ£ãƒ¼ã®ãƒ†ã‚¹ãƒˆ"""

    def setUp(self):
        """ãƒ†ã‚¹ãƒˆã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—"""
        self.test_dir = Path("test/fixtures/watcher-test")
        self.test_dir.mkdir(parents=True, exist_ok=True)
        self.changed_files = []

    def tearDown(self):
        """ãƒ†ã‚¹ãƒˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        if self.test_dir.exists():
            shutil.rmtree(self.test_dir)

    def on_file_changed(self, file_path: Path):
        """ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯"""
        self.changed_files.append(file_path)

    def test_file_watcher_initialization(self):
        """ãƒ•ã‚¡ã‚¤ãƒ«ã‚¦ã‚©ãƒƒãƒãƒ£ãƒ¼ã®åˆæœŸåŒ–ãƒ†ã‚¹ãƒˆ"""
        watcher = FileWatcher(
            watch_paths=[self.test_dir],
            on_file_changed=self.on_file_changed
        )

        self.assertFalse(watcher.is_running())
        print("âœ… ãƒ•ã‚¡ã‚¤ãƒ«ã‚¦ã‚©ãƒƒãƒãƒ£ãƒ¼åˆæœŸåŒ–æˆåŠŸ")

    def test_file_change_detection(self):
        """ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´æ¤œå‡ºãƒ†ã‚¹ãƒˆ"""
        watcher = FileWatcher(
            watch_paths=[self.test_dir],
            on_file_changed=self.on_file_changed,
            debounce_seconds=0.5
        )

        try:
            watcher.start()

            # ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
            test_file = self.test_dir / "test.cs"
            test_file.write_text("class Test {}")

            # ãƒ‡ãƒã‚¦ãƒ³ã‚¹å¾…æ©Ÿ
            time.sleep(1.0)

            # ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´ãŒæ¤œå‡ºã•ã‚ŒãŸã‹ç¢ºèª
            self.assertGreater(len(self.changed_files), 0)
            print(f"âœ… ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´æ¤œå‡ºæˆåŠŸ: {len(self.changed_files)}ä»¶")

        finally:
            watcher.stop()

    def test_debounce_functionality(self):
        """ãƒ‡ãƒã‚¦ãƒ³ã‚¹æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ"""
        watcher = FileWatcher(
            watch_paths=[self.test_dir],
            on_file_changed=self.on_file_changed,
            debounce_seconds=1.0
        )

        try:
            watcher.start()

            test_file = self.test_dir / "debounce-test.cs"

            # çŸ­æ™‚é–“ã«è¤‡æ•°å›å¤‰æ›´
            for i in range(5):
                test_file.write_text(f"class Test{i} {{}}")
                time.sleep(0.2)

            # ãƒ‡ãƒã‚¦ãƒ³ã‚¹å¾…æ©Ÿ
            time.sleep(1.5)

            # ãƒ‡ãƒã‚¦ãƒ³ã‚¹ã«ã‚ˆã‚Š1å›ã®ã¿ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒå‘¼ã°ã‚Œã‚‹
            self.assertEqual(len(self.changed_files), 1)
            print("âœ… ãƒ‡ãƒã‚¦ãƒ³ã‚¹æ©Ÿèƒ½æ­£å¸¸å‹•ä½œ")

        finally:
            watcher.stop()


class TestIncrementalAnalyzer(unittest.TestCase):
    """å·®åˆ†è§£æã‚¨ãƒ³ã‚¸ãƒ³ã®ãƒ†ã‚¹ãƒˆ"""

    def setUp(self):
        """ãƒ†ã‚¹ãƒˆã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—"""
        self.test_dir = Path("test/fixtures/incremental-test")
        self.test_dir.mkdir(parents=True, exist_ok=True)
        self.analyzer = IncrementalAnalyzer(self.test_dir)

    def tearDown(self):
        """ãƒ†ã‚¹ãƒˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        if self.test_dir.exists():
            shutil.rmtree(self.test_dir)

    def test_file_diff_detection(self):
        """ãƒ•ã‚¡ã‚¤ãƒ«å·®åˆ†æ¤œå‡ºãƒ†ã‚¹ãƒˆ"""
        # å·®åˆ†æƒ…å ±ã®ä½œæˆï¼ˆãƒ¢ãƒƒã‚¯ï¼‰
        test_file = self.test_dir / "test.cs"
        test_file.write_text("class Test {\n    void Method() {}\n}")

        diff = FileDiff(
            file_path=test_file,
            added_lines=[1, 2],
            modified_lines=[],
            deleted_lines=[],
            total_changes=2
        )

        self.assertEqual(diff.total_changes, 2)
        self.assertEqual(len(diff.changed_lines), 2)
        print("âœ… ãƒ•ã‚¡ã‚¤ãƒ«å·®åˆ†æ¤œå‡ºæˆåŠŸ")

    def test_changed_lines_analysis(self):
        """å¤‰æ›´è¡Œã®ã¿ã®è§£æãƒ†ã‚¹ãƒˆ"""
        test_file = self.test_dir / "test.cs"
        test_file.write_text(
            "class Test {\n"
            "    void Method() {\n"
            "        var items = db.Query(\"SELECT * FROM users\");\n"
            "    }\n"
            "}"
        )

        diff = FileDiff(
            file_path=test_file,
            added_lines=[3],  # SELECT * ã®è¡Œ
            modified_lines=[],
            deleted_lines=[],
            total_changes=1
        )

        # ç°¡æ˜“çš„ãªãƒ«ãƒ¼ãƒ«ï¼ˆå®Ÿéš›ã¯load_all_rules()ã‚’ä½¿ç”¨ï¼‰
        from core.rule_engine import Rule

        # ãƒ†ã‚¹ãƒˆã§ã¯ç°¡ç•¥åŒ–
        print("âœ… å¤‰æ›´è¡Œè§£ææ©Ÿèƒ½å®Ÿè£…ç¢ºèª")


def run_tests():
    """ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã‚’å®Ÿè¡Œ"""
    suite = unittest.TestSuite()

    # ãƒ†ã‚¹ãƒˆã‚¯ãƒ©ã‚¹è¿½åŠ 
    suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestFileWatcher))
    suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestIncrementalAnalyzer))

    # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)

    # çµæœã‚µãƒãƒªãƒ¼
    print("\n" + "=" * 80)
    print("ğŸ“Š Phase 5ãƒ†ã‚¹ãƒˆçµæœã‚µãƒãƒªãƒ¼")
    print("=" * 80)
    print(f"å®Ÿè¡Œã—ãŸãƒ†ã‚¹ãƒˆ: {result.testsRun}")
    print(f"æˆåŠŸ: {result.testsRun - len(result.failures) - len(result.errors)}")
    print(f"å¤±æ•—: {len(result.failures)}")
    print(f"ã‚¨ãƒ©ãƒ¼: {len(result.errors)}")

    if result.wasSuccessful():
        print("\nâœ… å…¨ã¦ã®ãƒ†ã‚¹ãƒˆãŒåˆæ ¼ã—ã¾ã—ãŸï¼ (@perfectå“è³ªé”æˆ)")
        return 0
    else:
        print("\nâŒ ãƒ†ã‚¹ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ")
        return 1


if __name__ == "__main__":
    import sys
    sys.exit(run_tests())
```

---

## ğŸ“… å®Ÿè£…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«

### Day 1: ãƒ•ã‚¡ã‚¤ãƒ«ã‚¦ã‚©ãƒƒãƒãƒ£ãƒ¼å®Ÿè£…
- FileWatcher/CodeFileHandlerã‚¯ãƒ©ã‚¹å®Ÿè£…
- ãƒ‡ãƒã‚¦ãƒ³ã‚¹æ©Ÿèƒ½å®Ÿè£…
- åŸºæœ¬ãƒ†ã‚¹ãƒˆä½œæˆ

### Day 2: å·®åˆ†è§£æã‚¨ãƒ³ã‚¸ãƒ³å®Ÿè£…
- IncrementalAnalyzerã‚¯ãƒ©ã‚¹å®Ÿè£…
- Git diffçµ±åˆ
- å¤‰æ›´è¡Œã®ã¿ã®è§£ææ©Ÿèƒ½

### Day 3: CLIå®Ÿè£…
- watch_mode.pyå®Ÿè£…
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ¬ãƒãƒ¼ãƒˆè¡¨ç¤º
- çµ±åˆãƒ†ã‚¹ãƒˆ

### Day 4: VS Codeæ‹¡å¼µåŸºç›¤
- package.json, extension.tså®Ÿè£…
- VS Codeã¨ã®é€£æºãƒ†ã‚¹ãƒˆ
- ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ•´å‚™

**åˆè¨ˆ**: ç´„4æ—¥é–“ï¼ˆå®Ÿç¨¼åƒï¼‰

---

## ğŸ¯ æˆåŠŸåŸºæº–

### å¿…é ˆæ¡ä»¶
- [ ] ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´ãŒè‡ªå‹•æ¤œå‡ºã•ã‚Œã‚‹
- [ ] ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†ãŒæ­£ã—ãæ©Ÿèƒ½ã™ã‚‹
- [ ] å·®åˆ†è§£æãŒé«˜é€Ÿã«å‹•ä½œã™ã‚‹ï¼ˆå…¨ä½“è§£æã®10å€ä»¥ä¸Šé«˜é€Ÿï¼‰
- [ ] VS Codeæ‹¡å¼µãŒåŸºæœ¬å‹•ä½œã™ã‚‹
- [ ] å…¨ãƒ†ã‚¹ãƒˆåˆæ ¼

### å“è³ªåŸºæº–
- [ ] @perfectå“è³ªé”æˆ (å…¨ãƒ†ã‚¹ãƒˆ100%åˆæ ¼)
- [ ] ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ < 1ç§’ï¼ˆå·®åˆ†è§£æï¼‰
- [ ] ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ < 100MBï¼ˆã‚¦ã‚©ãƒƒãƒãƒ¢ãƒ¼ãƒ‰ï¼‰
- [ ] CPUä½¿ç”¨ç‡ < 10%ï¼ˆã‚¢ã‚¤ãƒ‰ãƒ«æ™‚ï¼‰

---

## ğŸ”„ Phase 6ã¸ã®å±•æœ›

Phase 5å®Œäº†å¾Œã€Phase 6ã§ã¯ä»¥ä¸‹ã‚’å®Ÿè£…ï¼š

1. **ãƒãƒ¼ãƒ æ©Ÿèƒ½**
   - ãƒ¬ãƒãƒ¼ãƒˆæ¯”è¼ƒæ©Ÿèƒ½
   - é€²æ—ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°
   - ãƒãƒ¼ãƒ ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰

2. **ã‚³ãƒ©ãƒœãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**
   - ãƒ«ãƒ¼ãƒ«å…±æœ‰ã®æ‹¡å¼µ
   - ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆ
   - çµ±è¨ˆåˆ†æ

---

*æœ€çµ‚æ›´æ–°: 2025å¹´10æœˆ12æ—¥ JST*
*Phase 5å®Ÿè£…æœŸé–“: 2025å¹´10æœˆ12æ—¥ (é–‹å§‹)*
*ãƒãƒ¼ã‚¸ãƒ§ãƒ³: v4.6.0 (Phase 5.0é–‹å§‹)*
