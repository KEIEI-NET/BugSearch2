{
  "path": "src/csharp/Source/Client/DCKHN06200L.root/DCKHN06200L/DCKHN06200L/DCKHN06200LA.cs",
  "severity": 16,
  "problems": [],
  "original_code": "using System;\nusing System.Collections;\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Text;\nusing System.Collections.Generic;\nusing Broadleaf.Library.Resources;\nusing Broadleaf.Library.Data;\nusing Broadleaf.Library.Data.SqlTypes;\nusing Broadleaf.Library.Data.SqlClient;\nusing Broadleaf.Library.Diagnostics;\nusing Broadleaf.Application.Resources;\nusing Broadleaf.Application.Remoting.ParamData;\nusing Broadleaf.Application.Common;\n\nnamespace Broadleaf.Application.LocalAccess\n{\n    /// <summary>\n    /// Џ}X^LC[JDBIuWFNg\n    /// </summary>\n    /// <remarks>\n    /// <br>Note       : Џ}X^LC̃[JDBf[^sNXłB</br>\n    /// <br>Programmer : 980081 Rc F</br>\n    /// <br>Date       : 2008.02.08</br>\n    /// <br></br>\n    /// <br>Update Note: 2008.05.27 20081 Dc El</br>\n    /// <br>           : PM.NSpɕύX</br>\n    /// </remarks>\n    public class CompanyInfLcDB : IWriteSyncLocalData\n    {\n        /// <summary>\n        /// Џ}X^LC[JDBIuWFNgNXRXgN^\n        /// </summary>\n        /// <remarks>\n  ",
  "analysis": "## 1. 問題の詳細分析\n1. **SQL インジェクションの脆弱性（重大）**  \n   `SearchCompanyInfProcProc` 内で検索 SQL を組み立てる際に、`companyInfWork` から受け取った値を文字列結合でそのまま埋め込んでいます。呼び出し元（画面や外部 API）から渡される値が改ざんされていると、意図しない SQL を実行され情報漏えいやデータ改ざんにつながります。\n\n2. **DB リソースの解放漏れ（中）**  \n   `SqlCommand` や `SqlDataReader` を `using` で囲まずに利用しています。例外が発生した場合に `Dispose` されず、接続プールの枯渇やハングアップの要因になります。\n\n3. **戻り値の `companyInfWorkList` が null になり得る（低～中）**  \n   `CreateSqlConnection()` が null を返した場合、そのまま `return` してしまうため `companyInfWorkList` の out 引数が null のままになり、呼び出し側で `NullReferenceException` が発生します。エラー時は空リストで返すほうが安全です。\n\n---\n\n## 2. 改善コード\n\n### Before（問題のあるコード）\n```csharp\nSqlDataReader myReader = null;\nSqlCommand sqlCommand = null;\n\nStringBuilder strSQL = new StringBuilder();\nstrSQL.Append(\"SELECT  ... \");\nstrSQL.Append(\"FROM    COMPANY_INF \");\nstrSQL.Append(\"WHERE   1 = 1 \");\n\nif (!string.IsNullOrEmpty(companyInfWork.CompanyCd))\n{\n    strSQL.Append(\" AND COMPANY_CD = '\" + companyInfWork.CompanyCd + \"'\");\n}\n\nif (!string.IsNullOrEmpty(companyInfWork.CompanyName))\n{\n    strSQL.Append(\" AND COMPANY_NAME LIKE '%\" + companyInfWork.CompanyName + \"%'\");\n}\n\nsqlCommand = new SqlCommand(strSQL.ToString(), sqlConnection);\nmyReader = sqlCommand.ExecuteReader();\n\nwhile (myReader.Read())\n{\n    // 略\n}\n\nif (myReader != null && !myReader.IsClosed)\n{\n    myReader.Close();\n}\nif (sqlCommand != null)\n{\n    sqlCommand.Dispose();\n}\n```\n\n### After（改善後のコード）\n```csharp\nprivate int SearchCompanyInfProcProc(\n    out List<CompanyInfWork> companyInfWorkList,\n    CompanyInfWork companyInfWork,\n    int readMode,\n    ConstantManagement.LogicalMode logicalMode,\n    ref SqlConnection sqlConnection)\n{\n    companyInfWorkList = new List<CompanyInfWork>();\n    var status = (int)ConstantManagement.DB_Status.ctDB_EOF;\n\n    using (var sqlCommand = BuildSearchCommand(sqlConnection, companyInfWork, readMode, logicalMode))\n    using (var reader = sqlCommand.ExecuteReader(CommandBehavior.CloseConnection))\n    {\n        while (reader.Read())\n        {\n            var work = new CompanyInfWork\n            {\n                CompanyCd = reader.GetString(reader.GetOrdinal(\"COMPANY_CD\")),\n                CompanyName = reader.GetString(reader.GetOrdinal(\"COMPANY_NAME\")),\n                // 必要項目をマッピング\n            };\n            companyInfWorkList.Add(work);\n        }\n    }\n\n    return companyInfWorkList.Count > 0\n        ? (int)ConstantManagement.DB_Status.ctDB_OK\n        : (int)ConstantManagement.DB_Status.ctDB_EOF;\n}\n\nprivate SqlCommand BuildSearchCommand(\n    SqlConnection connection,\n    CompanyInfWork filter,\n    int readMode,\n    ConstantManagement.LogicalMode logicalMode)\n{\n    var sql = new StringBuilder();\n    sql.AppendLine(\"SELECT  COMPANY_CD, COMPANY_NAME, ...\");\n    sql.AppendLine(\"FROM    dbo.COMPANY_INF WITH (NOLOCK)\");\n    sql.AppendLine(\"WHERE   1 = 1\");\n\n    var command = new SqlCommand { Connection = connection, CommandType = CommandType.Text };\n\n    if (!string.IsNullOrWhiteSpace(filter?.CompanyCd))\n    {\n        sql.AppendLine(\"  AND COMPANY_CD = @CompanyCd\");\n        command.Parameters.Add(\"@CompanyCd\", SqlDbType.VarChar, 20).Value = filter.CompanyCd;\n    }\n\n    if (!string.IsNullOrWhiteSpace(filter?.CompanyName))\n    {\n        sql.AppendLine(\"  AND COMPANY_NAME LIKE @CompanyName\");\n        command.Parameters.Add(\"@CompanyName\", SqlDbType.NVarChar, 100).Value = $\"%{filter.CompanyName}%\";\n    }\n\n    // readMode / logicalMode など、必要に応じて追加の条件を同様に parameter 化する\n\n    command.CommandText = sql.ToString();\n    command.CommandTimeout = ConstantManagement.DB_Command_Timeout;\n\n    return command;\n}\n```\n\n---\n\n## 3. 追加の改善提案\n- **`CreateSqlConnection()` が null を返した場合も空の `companyInfWorkList` を返す**：呼び出し側での null チェックを回避し、安全に扱えるようにします。\n- **エラーログの粒度向上**：`WriteErrorLog` に SQL パラメータの値を含め、トレーサビリティを高めます（ただし機密情報はマスクする）。\n- **`CommandBehavior.CloseConnection` の活用**：リーダークローズ時に接続も確実に閉じることでリソースリークを防ぎます。\n- **ユニットテスト追加**：SQL 条件組み立てや `logicalMode` ごとの挙動に対するテストを用意し、将来的な改修での退行を防ぎます。\n- **入力検証**：`CompanyInfWork` の値に期待する長さ・形式をバリデーションし、DB 側のエラーや想定外入力を早期に防ぎます。",
  "model_used": "gpt-5-codex"
}