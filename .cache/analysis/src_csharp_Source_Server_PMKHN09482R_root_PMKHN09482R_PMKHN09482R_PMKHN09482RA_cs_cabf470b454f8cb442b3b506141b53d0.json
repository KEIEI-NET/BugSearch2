{
  "path": "src/csharp/Source/Server/PMKHN09482R.root/PMKHN09482R/PMKHN09482R/PMKHN09482RA.cs",
  "severity": 21,
  "problems": [],
  "original_code": "//****************************************************************************//\n// VXe         : PM.NS\n// vO   : |ݒ}X^i|DǗp^[j \n// vOTv   : |ݒ}X^i|DǗp^[j֘As\n//----------------------------------------------------------------------------//\n//                (c)Copyright  2010 Broadleaf Co.,Ltd.\n//============================================================================//\n// \n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : \n//     2010/08/10  Ce : VK쐬\n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : \n// C                Ce : \n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : \n// C    2010/09/10  Ce : QEǑΉ8ذ\n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : \n// C    2010/09/26  Ce : dlA #14492Ή\n//-----------------------------------------------------------------------",
  "analysis": "## 1. 問題の詳細分析\n1. **SQLインジェクションの危険性（重大）**  \n   `SearchProc` で組み立てている検索SQLは、`rateProtyMngWork` から受け取った値を文字列連結でそのまま埋め込んでいます。  \n   例：  \n   ```\n   sql.Append(\" AND \" + _dataColumnCd + \" = '\" + rateProtyMngWork.DataColumnCd + \"'\");\n   ```  \n   このようなコードは攻撃者に `' OR '1'='1` や `'; DROP TABLE ...` といった文字列を送り込まれると、データの漏えいや破壊につながる深刻な SQL インジェクションを引き起こします。  \n   `RateProtyMngPatternDB` はリモート呼び出しを受け付けるコンポーネントであるため、外部から不正な入力を受け取る可能性が高く、危険度は非常に高いです。\n\n2. **動的テーブル名・カラム名の組み込み（重大）**  \n   `_tableName`、`_dataColumnCd` などの列名・テーブル名が、`rateProtyMngWork` から渡される値をほぼ無検証で採用しています。  \n   例：  \n   ```\n   _tableName = rateProtyMngWork.TableName;\n   selectSql.Append(\"SELECT ... FROM \" + _tableName);\n   ```  \n   テーブル名やカラム名が任意に指定できる状態は、攻撃者に別テーブルを読み取られたり、SQLインジェクションを助長するなど、権限外データへのアクセスを許します。  \n   少なくともホワイトリストによるチェックが必須です。\n\n## 2. 改善コード\n### Before（問題のあるコード）\n```\nStringBuilder selectSql = new StringBuilder();\nselectSql.Append(\"SELECT ... \");\nselectSql.Append(\"FROM \" + _tableName + \" \");\nselectSql.Append(\"WHERE 1 = 1 \");\n\nif (!string.IsNullOrEmpty(rateProtyMngWork.DataColumnCd))\n{\n    selectSql.Append(\" AND \" + _dataColumnCd + \" = '\" + rateProtyMngWork.DataColumnCd + \"'\");\n}\n\nif (!string.IsNullOrEmpty(rateProtyMngWork.RateSettingDivide))\n{\n    selectSql.Append(\" AND \" + _rateSettingDivide + \" = '\" + rateProtyMngWork.RateSettingDivide + \"'\");\n}\n\nSqlCommand sqlCommand = new SqlCommand(selectSql.ToString(), sqlConnection);\nSqlDataReader reader = sqlCommand.ExecuteReader();\n```\n\n### After（改善後のコード）\n```\nprivate static readonly IReadOnlyDictionary<string, (string Table, string ColumnCd, string ColumnName)> RateSettingMeta =\n    new Dictionary<string, (string, string, string)>(StringComparer.OrdinalIgnoreCase)\n    {\n        // 有効な区分だけをここに明示的に登録する\n        { \"A\", (\"T_RATE_PROTY_A\", \"DATA_COLUMN_CD\", \"DATA_COLUMN_NM\") },\n        { \"B\", (\"T_RATE_PROTY_B\", \"DATA_COLUMN_CD\", \"DATA_COLUMN_NM\") },\n        // ...\n    };\n\nprivate int SearchProc(out ArrayList rateProtyMngList,\n                       RateProtyMngWork rateProtyMngWork,\n                       int readMode,\n                       ConstantManagement.LogicalMode logicalMode,\n                       SqlConnection sqlConnection)\n{\n    rateProtyMngList = new ArrayList();\n\n    if (!RateSettingMeta.TryGetValue(rateProtyMngWork.RateSettingDivide, out var meta))\n    {\n        throw new InvalidOperationException(\"Invalid rate setting divide.\");\n    }\n\n    string tableName = meta.Table;\n    string dataColumnCd = meta.ColumnCd;\n    string dataColumnName = meta.ColumnName;\n\n    var sql = new StringBuilder();\n    sql.AppendLine($@\"\n        SELECT\n            {dataColumnCd},\n            {dataColumnName},\n            ...\n        FROM {tableName}\n        WHERE 1 = 1\");\n\n    var command = new SqlCommand { Connection = sqlConnection };\n    if (!string.IsNullOrEmpty(rateProtyMngWork.DataColumnCd))\n    {\n        sql.AppendLine($\" AND {dataColumnCd} = @DataColumnCd\");\n        command.Parameters.Add(\"@DataColumnCd\", SqlDbType.NVarChar, 50).Value =\n            rateProtyMngWork.DataColumnCd.Trim();\n    }\n\n    if (!string.IsNullOrEmpty(rateProtyMngWork.RateSettingDivide))\n    {\n        sql.AppendLine(\" AND RateSettingDivide = @RateSettingDivide\");\n        command.Parameters.Add(\"@RateSettingDivide\", SqlDbType.NVarChar, 10).Value =\n            rateProtyMngWork.RateSettingDivide.Trim();\n    }\n\n    command.CommandText = sql.ToString();\n    using (var reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // 取得処理\n        }\n    }\n\n    return (int)ConstantManagement.DB_Status.ctDB_OK;\n}\n```\n\n- **対策のポイント**\n  - テーブル名やカラム名は外部入力を直接使わず、ホワイトリスト（辞書）でマッピング。\n  - 値部分は `SqlParameter` を使ってプレースホルダ化し、`Add` で割り当てる。\n  - 文字列トリムや長さ制約で予期せぬ入力を排除する。\n\n## 3. 追加の改善提案\n- `SqlConnection`・`SqlCommand` などは `using` ブロックで確実に破棄する（例外時にもリソースリークを防止）。\n- 入力オブジェクト (`RateProtyMngWork`) のフィールドについて、数値項目/日付などの型チェック、最大文字数などを共通層でバリデーションする。\n- ログにはパラメータ化された情報と例外スタックを正しく記録し、SQL文字列（特にプレーン連結されたもの）を残さないことで機密/攻撃情報の漏えいを防ぐ。\n- 単一メソッドが長大になっている場合は、SQL組み立て・パラメータ設定・結果変換などに役割分割し、テスト容易性と保守性を高める。\n- 可能であれば OR/M（Entity Framework など）の採用や共通クエリビルダーを用いて SQL 組み立ての安全性をフレームワーク側で担保する。",
  "model_used": "gpt-5-codex"
}