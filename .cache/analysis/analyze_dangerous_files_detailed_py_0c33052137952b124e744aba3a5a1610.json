{
  "path": "analyze_dangerous_files_detailed.py",
  "severity": 30,
  "problems": [],
  "original_code": "#!/usr/bin/env python3\n\"\"\"\n危険度の高いファイルを個別にAI分析するスクリプト（詳細版・完全コード提案付き）\n\"\"\"\n\nimport json\nimport pathlib\nimport re\nimport time\nimport sys\nfrom typing import List, Dict, Any\n\ndef extract_dangerous_files(report_path: pathlib.Path, min_score: int = 1) -> List[Dict[str, Any]]:\n    \"\"\"危険度レポートから問題のあるファイルを抽出（問題なし以外）\"\"\"\n    files = []\n\n    if not report_path.exists():\n        print(f\"レポートファイルが見つかりません: {report_path}\")\n        return files\n\n    content = report_path.read_text(encoding='utf-8')\n    sections = content.split('\\n###')\n\n    for section in sections:\n        if 'csharp/' in section:\n            # 「問題なし」のファイルはスキップ\n            if '問題なし' in section:\n                continue\n\n            lines = section.strip().split('\\n')\n            if lines:\n                first_line = lines[0].strip()\n                path_match = re.search(r'csharp/[^\\s]+\\.(cs|py|java|js|ts|aspx)', first_line)\n\n                if path_match:\n                    file_path = 'src/' + path_match.group()\n\n                    s",
  "analysis": "## 1. 問題の詳細分析\n\n### 問題1：ファイルパスを固定的に書き換えてしまう（`'src/' + path_match.group()`）\n- **危険性**：レポートに記載されたパスを強制的に `src/` 配下に差し替えるため、レポートのディレクトリ構成と実際のリポジトリ構成が異なるとファイルを見つけられません。分析対象ファイルを読み出せず、後続処理がすべて空振りしてしまう危険があります。\n- **影響**：\n  - 本来分析すべきファイルを読み込めず、結果として危険なコードを見逃す。\n  - 分析結果が常に「空」になり、運用上「問題なし」と誤認しやすい。\n\n### 問題2：プログラミング言語の抽出が不完全（`lang_match = re.search(r'言語[^:]*:\\s*(\\w+)', line)`）\n- **危険性**：`\\w+` は英数字とアンダースコアのみを対象にしているため、「C#」「C++」「TypeScript」など記号やハイフンを含む言語名を取得できません。結果的に `language` が常に `unknown` となり、生成される改善コードやアドバイスが的外れになります。\n- **影響**：\n  - 不正確な言語判定により、改善提案やコードテンプレートが実際の言語と合わなくなり、誤った修正案を提示する。\n  - 自動処理（例：言語別テンプレート適用）が破綻する。\n\n### 問題3：問題抽出ロジックが重複・過検出しやすい（`problems.append(...)` を条件分岐ごとに実行）\n- **危険性**：同じ問題が複数行で検出されると重複してリストに追加されます。また単純な `in` 検索のため、意図しない箇所（コメント等）を拾うこともあります。過剰な重複や誤検出が起きると、優先度判断を誤らせ、対応コストの増大につながります。\n- **影響**：\n  - 問題リストが同じ内容で溢れ、利用者が本当に重要な問題を見失う。\n  - 誤検出による不要な改修を誘発する。\n\n---\n\n## 2. 改善コード\n\n### Before（問題のあるコード）\n```python\nif path_match:\n    file_path = 'src/' + path_match.group()\n\n    score = 0\n    for line in lines:\n        score_match = re.search(r'スコア:\\s*(\\d+)', line)\n        if score_match:\n            score = int(score_match.group(1))\n            break\n\n    language = 'unknown'\n    for line in lines:\n        lang_match = re.search(r'言語[^:]*:\\s*(\\w+)', line)\n        if lang_match:\n            language = lang_match.group(1)\n            break\n\n    problems = []\n    for line in lines:\n        if '入力検証' in line:\n            problems.append('入力検証が不十分')\n        if 'N+1' in line or 'ループ内SELECT' in line:\n            problems.append('DB: ループ内SELECT (N+1) 疑い')\n        if 'SELECT *' in line or 'SELECT * ' in line:\n            problems.append('DB: SELECT * →負荷増')\n        if '浮動小数' in line or 'float' in line:\n            problems.append('金額: 浮動小数で金額計算')\n        if 'ダイアログ' in line:\n            problems.append('UI: ダイアログ多用')\n\n    if score >= min_score and problems:\n        files.append({\n            'path': file_path,\n            'score': score,\n            'language': language,\n            'problems': problems\n        })\n```\n\n### After（改善後のコード）\n```python\nif path_match:\n    # レポートに記載されているパスをそのまま利用（存在確認は後段で実施）\n    file_path = path_match.group()\n\n    score = 0\n    for line in lines:\n        score_match = re.search(r'スコア:\\s*(\\d+)', line)\n        if score_match:\n            score = int(score_match.group(1))\n            break\n\n    language = 'unknown'\n    for line in lines:\n        lang_match = re.search(r'言語[^:]*:\\s*([^\\s]+)', line)\n        if lang_match:\n            language = lang_match.group(1)\n            break\n\n    detected_problems = set()\n    for line in lines:\n        normalized = line.strip()\n        if '入力検証' in normalized:\n            detected_problems.add('入力検証が不十分')\n        if 'N+1' in normalized or 'ループ内SELECT' in normalized:\n            detected_problems.add('DB: ループ内SELECT (N+1) 疑い')\n        if re.search(r'\\bSELECT\\s+\\*\\b', normalized, re.IGNORECASE):\n            detected_problems.add('DB: SELECT * →負荷増')\n        if '浮動小数' in normalized or re.search(r'\\bfloat\\b', normalized, re.IGNORECASE):\n            detected_problems.add('金額: 浮動小数で金額計算')\n        if 'ダイアログ' in normalized:\n            detected_problems.add('UI: ダイアログ多用')\n\n    if score >= min_score and detected_problems:\n        files.append({\n            'path': file_path,\n            'score': score,\n            'language': language,\n            'problems': sorted(detected_problems)\n        })\n```\n\n---\n\n## 3. 追加の改善提案\n1. **パスの基点を設定可能にする**：呼び出し元でレポートのパス形式と実際のリポジトリ構成が異なることもあるため、`base_path` を外部から渡せるようにし、存在確認時に結合する仕組みを導入すると柔軟に対応できます。\n2. **正規表現のマッチ範囲を広げる**：`path_match` も `section` 全体から探すようにし、`csharp/` 固定ではなくターゲット言語を外部設定にすることで、他言語レポートにも再利用しやすくなります。\n3. **ソース読み込みエラーハンドリングの改善**：`read_source_file` 内で読み込み失敗時にログレベルを分けたり、最後に試したエンコーディングや例外内容をまとめて返すとデバッグが容易になります。",
  "model_used": "gpt-5-codex"
}