{
  "path": "src/csharp/Source/Server/PMKHN02057R.root/PMKHN02057R/PMKHN02057R/PMKHN02057RE.cs",
  "severity": 15,
  "problems": [],
  "original_code": "//****************************************************************************//\n// VXe         : .NSV[Y\n// vO   : Ly[ѕ\\\n// vOTv   : Ly[ѕ\\@Sҕʗp\n//----------------------------------------------------------------------------//\n//                (c)Copyright  2011 Broadleaf Co.,Ltd.\n//============================================================================//\n// \n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : c\n//     2011/05/19  Ce : VK쐬\n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : \n//     2011/07/05  Ce : Redmine Q #22746 ̑Ή\n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : \n//     2011/07/07  Ce : Redmine dlA #22792 ̑Ή\n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : \n//     2011/07/11  Ce : Redmine dlύX #22860 ̑Ή\n//------------------------------------------",
  "analysis": "## 1. 問題の詳細分析\n1. **SQLインジェクションの脆弱性**  \n   `MakeSalesSelectStringProc` 内で `CampaignstRsltListPrtWork` から受け取った値を、そのまま文字列連結で SQL 文に埋め込んでいます。ユーザ入力が直接 `WHERE` 句に入り込むため、特別に細工した値を渡すことで任意の SQL を実行でき、情報漏洩・改ざん・削除といった重大な被害が発生する可能性があります。\n\n2. **パラメータ再利用時の競合/上書きリスク**  \n   同じプレースホルダー名を複数条件で使い回しているため、後から追加した条件で値が上書きされ、意図しない検索結果になる恐れがあります。また、同じ `SqlCommand` を再利用する際に `Parameters.Clear()` や重複チェックが無いため、ランタイムエラーが発生する可能性もあります。\n\n## 2. 改善コード\n### Before（問題のあるコード）\n```csharp\nif (!string.IsNullOrEmpty(CndtnWork.AddUpSecCode))\n{\n    strWhere.Append(\" AND TTL_EMP.ADD_UP_SEC_CD = '\" + CndtnWork.AddUpSecCode + \"'\");\n    bAddUpSecCode = true;\n}\n\nif (!string.IsNullOrEmpty(CndtnWork.CustomerCode))\n{\n    strWhere.Append(\" AND TTL_EMP.CUST_CD = '\" + CndtnWork.CustomerCode + \"'\");\n    bCustomerCode = true;\n}\n```\n\n### After（改善後のコード）\n```csharp\n// 事前に明示的にパラメータをクリアする\nsqlCommand.Parameters.Clear();\n\nif (!string.IsNullOrEmpty(CndtnWork.AddUpSecCode))\n{\n    strWhere.Append(\" AND TTL_EMP.ADD_UP_SEC_CD = @AddUpSecCd\");\n    sqlCommand.Parameters.Add(\"@AddUpSecCd\", SqlDbType.NVarChar, 30)\n                         .Value = CndtnWork.AddUpSecCode;\n    bAddUpSecCode = true;\n}\n\nif (!string.IsNullOrEmpty(CndtnWork.CustomerCode))\n{\n    strWhere.Append(\" AND TTL_EMP.CUST_CD = @CustomerCd\");\n    sqlCommand.Parameters.Add(\"@CustomerCd\", SqlDbType.NVarChar, 30)\n                         .Value = CndtnWork.CustomerCode;\n    bCustomerCode = true;\n}\n```\n\n> ※ 他の条件句（所属部門コード、商品番号、メーカーコード、BLグループコード等）も同様に、  \n> 文字列連結を廃し、個々の条件ごとに **固有のプレースホルダー名** を用いて `SqlParameter` を追加してください。\n\n## 3. 追加の改善提案\n- `ORDER BY` や `GROUP BY` で列名を動的に変更している箇所があれば、ホワイトリスト方式で検証し、不正な列名を拒否する仕組みを追加してください。  \n- `SqlCommand`／`SqlConnection` を `using` ブロックで管理し、想定外の例外発生時でも確実にリソースが解放されるようにすると堅牢性が高まります。  \n- `_finYearTableGenerator` を利用する前に null チェックを行い、取得に失敗した場合のフォールバック処理やログ出力を準備しておくと、運用時のトラブルシュートが容易になります。",
  "model_used": "gpt-5-codex"
}