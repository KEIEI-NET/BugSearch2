{
  "path": "src/csharp/Source/Server/DCTOK02144R.root/DCTOK02144R/DCTOK02144R/DCTOK02144RC.cs",
  "severity": 15,
  "problems": [],
  "original_code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Text;\nusing Broadleaf.Application.Remoting.ParamData;\nusing Broadleaf.Library.Resources;\nusing Broadleaf.Library.Data;\nusing Broadleaf.Library.Data.SqlTypes;\nusing Broadleaf.Library.Data.SqlClient;\nusing Broadleaf.Xml.Serialization;\nusing Broadleaf.Application.Resources;\nusing Broadleaf.Library.Globarization;\n\nnamespace Broadleaf.Application.Remoting\n{\n    class MTtlSaSlipGoods : MTtlSaSlipBase, IMTtlSaSlip\n    {\n        #region [ʗptO錾]\n        private bool bAddUpSecCode = false;  //v㋒_R[h\n        private bool bGoodsMakerCd = false;  //i[J[R[h\n        private bool bBLGoodsCode = false;   //BLiR[h\n        private bool bGoodsNo = false;       //iԍ\n        private bool bBLGroupCode = false;   //BLO[vR[h\n        private bool bGoodsMGroup = false;   //iރR[h\n        private bool bGoodsLGroup = false;   //i啪ރR[h\n        #endregion  //[ʗptO錾]\n\n        #region [",
  "analysis": "## 1. 問題の詳細分析\n1. **状態を保持するフラグの再利用による不正なクエリ生成（中程度の危険度）**  \n   `bAddUpSecCode` などのフラグがクラスフィールドとして定義されており、`MakeSelectStringProc` 内で `true` に設定された後にリセットされません。  \n   - 同一インスタンスが再利用される環境（典型的なサーバー側コンポーネント）では、前回の呼び出しで立てたフラグが次回以降にも残り続け、必要以上の列がSELECT句に含まれたり、意図しない条件が追加される恐れがある。  \n   - また、複数スレッドから同インスタンスにアクセスされると、これらのフィールドが上書きされ、結果セットが不定になるだけでなく、他ユーザーの要求内容が混入するなど情報漏えいにつながるリスクがある。\n\n2. **メソッド内での状態初期化欠如によるメンテナンス性・可読性の低下**  \n   ロジックが「現在の入力条件」だけを見れば良いのに、外部状態（クラスフィールド）に依存した設計のため、挙動を追跡しにくく、バグを生みやすい。これにより、テストや将来的な機能追加時に予期せぬ副作用が発生する可能性が高い。\n\n## 2. 改善コード\n### Before（問題のあるコード）\n```csharp\nclass MTtlSaSlipGoods : MTtlSaSlipBase, IMTtlSaSlip\n{\n    #region [ʗptO錾]\n    private bool bAddUpSecCode = false;  //v㋒_R[h\n    private bool bGoodsMakerCd = false;  //i[J[R[h\n    private bool bBLGoodsCode = false;   //BLiR[h\n    private bool bGoodsNo = false;       //iԍ\n    private bool bBLGroupCode = false;   //BLO[vR[h\n    private bool bGoodsMGroup = false;   //iރR[h\n    private bool bGoodsLGroup = false;   //i啪ރR[h\n    #endregion  //[ʗptO錾]\n\n    private string MakeSelectStringProc(ref SqlCommand sqlCommand, SalesTransListCndtnWork CndtnWork)\n    {\n        //v㋒_R[h\n        if (CndtnWork.TtlType == 1)\n        {\n            bAddUpSecCode = true;\n        }\n\n        //iԍ\n        if (CndtnWork.Detail == 0)\n        {\n            bGoodsNo = true;\n        }\n        ...\n        string selectTxt = \"\";\n        selectTxt += \"SELECT\" + Environment.NewLine;\n        selectTxt += \"  GSMSLP.ENTERPRISECODERF\" + Environment.NewLine;\n        selectTxt += IFBy(bAddUpSecCode,\n                     \" ,GSMSLP.ADDUPSECCODERF\" + Environment.NewLine);\n        ...\n```\n\n### After（改善後のコード）\n```csharp\nclass MTtlSaSlipGoods : MTtlSaSlipBase, IMTtlSaSlip\n{\n    private string MakeSelectStringProc(ref SqlCommand sqlCommand, SalesTransListCndtnWork cndtnWork)\n    {\n        if (cndtnWork == null) throw new ArgumentNullException(nameof(cndtnWork));\n\n        // 入力条件から毎回ローカルで判定を行い、状態を外部に残さない\n        bool addUpSecCode = cndtnWork.TtlType == 1;\n        bool goodsNo = cndtnWork.Detail == 0;\n        bool goodsMakerCd =\n            cndtnWork.Detail == 0 ||\n            cndtnWork.Detail == 5 ||\n            (cndtnWork.MakerPrintDiv == 1 && (cndtnWork.Detail == 1 ||\n                                              cndtnWork.Detail == 2 ||\n                                              cndtnWork.Detail == 3 ||\n                                              cndtnWork.Detail == 4));\n        bool blGoodsCode = cndtnWork.Detail == 0 || cndtnWork.Detail == 1;\n        bool blGroupCode = cndtnWork.Detail == 0 || cndtnWork.Detail == 1 || cndtnWork.Detail == 2;\n        bool goodsMGroup = cndtnWork.Detail == 0 || cndtnWork.Detail == 1 ||\n                           cndtnWork.Detail == 2 || cndtnWork.Detail == 3;\n        bool goodsLGroup = cndtnWork.Detail == 0 || cndtnWork.Detail == 1 ||\n                           cndtnWork.Detail == 2 || cndtnWork.Detail == 3 || cndtnWork.Detail == 4;\n\n        var selectTxt = new StringBuilder();\n        selectTxt.AppendLine(\"SELECT\");\n        selectTxt.AppendLine(\"  GSMSLP.ENTERPRISECODERF\");\n\n        if (addUpSecCode)\n        {\n            selectTxt.AppendLine(\" ,GSMSLP.ADDUPSECCODERF\");\n        }\n        if (goodsNo)\n        {\n            selectTxt.AppendLine(\" ,GSMSLP.GOODSNO\");\n        }\n        if (goodsMakerCd)\n        {\n            selectTxt.AppendLine(\" ,MAKERU.MAKERCODERF\");\n        }\n        if (blGoodsCode)\n        {\n            selectTxt.AppendLine(\" ,BLGCDU.BLGDGRCODERF\");\n        }\n        if (blGroupCode)\n        {\n            selectTxt.AppendLine(\" ,BLGRPU.BLGROUPCODERF\");\n        }\n        if (goodsMGroup)\n        {\n            selectTxt.AppendLine(\" ,GSGRPU.GOODSMGROUPCODERF\");\n        }\n        if (goodsLGroup)\n        {\n            selectTxt.AppendLine(\" ,GSGRPU.GOODSLGROUPCODERF\");\n        }\n\n        // 以降の SELECT 文生成も同様に StringBuilder を使用する\n        // ...\n        return selectTxt.ToString();\n    }\n}\n```\n\n## 3. 追加の改善提案\n- `sqlCommand` を再利用する前に `sqlCommand.Parameters.Clear()` を行い、パラメータの混在を防ぐ。\n- 条件句の追加がある場合は必ず `SqlParameter` を利用し、文字列連結によるSQLインジェクションの可能性を排除する。\n- クラスにスレッドセーフな設計を適用（インスタンスをステートレス化する、または DI コンテナのスコープを per-request にする）。\n- 長大な SELECT 文生成は専用のビルダー／メソッドに分割し、意図を明確に保守性を向上させる。",
  "model_used": "gpt-5-codex"
}