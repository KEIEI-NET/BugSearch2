{
  "path": "src/csharp/Source/Server/PMKHN02057R.root/PMKHN02057R/PMKHN02057R/PMKHN02057RD.cs",
  "severity": 15,
  "problems": [],
  "original_code": "//****************************************************************************//\n// VXe         : .NSV[Y\n// vO   : Ly[ѕ\\\n// vOTv   : Ly[ѕ\\@Ӑʗp\n//----------------------------------------------------------------------------//\n//                (c)Copyright  2011 Broadleaf Co.,Ltd.\n//============================================================================//\n// \n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : c\n//     2011/05/19  Ce : VK쐬\n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : \n//     2011/07/05  Ce : Redmine Q #22746 ̑Ή\n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : \n//     2011/07/07  Ce : Redmine dlA #22792 ̑Ή\n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : \n//     2011/07/11  Ce : Redmine dlύX #22860 ̑Ή\n//-------------------------------------------",
  "analysis": "## 1. 問題の詳細分析\n1. **SQLインジェクションの脆弱性（危険度：高）**  \n   `MakeSalesSelectStringProc` 内では、`CampaignstRsltListPrtWork` から渡される値（顧客コードや部署コードなど）が、そのまま文字列連結で SQL の WHERE 句に組み込まれています。これらの値はリモートクライアントから送信される入力であるため、攻撃者が特殊文字（`'`、`;` など）を混入させれば任意の SQL を実行させることが可能となり、データの漏えい・改ざん・削除に直結します。\n\n2. **パラメーター再利用時の安全性不足（危険度：中）**  \n   `SqlCommand` を再利用して異なる条件でクエリを実行する際に、前回追加したパラメーターがクリアされず残存する実装になっています。そのため、想定外の値でクエリが実行されたり、パラメーター数が整合しないことによる例外が発生する恐れがあります。\n\n## 2. 改善コード\n### Before（問題のあるコード）\n```csharp\nif (!string.IsNullOrEmpty(CndtnWork.CustomerCodeFrom))\n{\n    sql.Append(\" AND C.CUSTOMER_CD >= '\" + CndtnWork.CustomerCodeFrom + \"'\");\n}\nif (!string.IsNullOrEmpty(CndtnWork.CustomerCodeTo))\n{\n    sql.Append(\" AND C.CUSTOMER_CD <= '\" + CndtnWork.CustomerCodeTo + \"'\");\n}\n```\n\n### After（改善後のコード）\n```csharp\nif (!string.IsNullOrEmpty(CndtnWork.CustomerCodeFrom))\n{\n    sql.Append(\" AND C.CUSTOMER_CD >= @CustomerCodeFrom\");\n    SqlParameter param = new SqlParameter(\"@CustomerCodeFrom\", SqlDbType.VarChar, 20)\n    {\n        Value = CndtnWork.CustomerCodeFrom\n    };\n    sqlCommand.Parameters.Add(param);\n}\n\nif (!string.IsNullOrEmpty(CndtnWork.CustomerCodeTo))\n{\n    sql.Append(\" AND C.CUSTOMER_CD <= @CustomerCodeTo\");\n    SqlParameter param = new SqlParameter(\"@CustomerCodeTo\", SqlDbType.VarChar, 20)\n    {\n        Value = CndtnWork.CustomerCodeTo\n    };\n    sqlCommand.Parameters.Add(param);\n}\n```\n\nさらに、`MakeSalesSelectStringProc` の先頭などで以下の処理を追加し、前回のパラメーターを確実にクリアしたうえで構築を開始します。\n\n```csharp\nsqlCommand.Parameters.Clear();\n```\n\n## 3. 追加の改善提案\n- **条件値のサニタイズ/バリデーション**：クライアントから渡されるコード類（顧客コード、部署コード、商品コードなど）が想定フォーマット（半角英数字など）であることを検証し、異常値の場合は処理を中断してログに記録するよう実装してください。\n- **テーブル名や列名の動的組み立てに対するホワイトリスト**：会計年度テーブル名などを動的に切り替える必要がある場合は、`FinYearTableGenerator` が返す値をホワイトリストで検証するか、内部的に安全な方法で解決させ、直接文字列連結で利用しないよう徹底してください。\n- **SqlCommand/SqlConnection の例外ハンドリングと using ブロック**：例外発生時に接続やコマンドが解放されないケースがあるため、`using` ブロックや `try/finally` を用いてリソースリークを防ぐようにしてください。\n- **スレッドセーフな状態管理**：クラスフィールドのフラグ（`bAddUpSecCode` など）をマルチスレッド環境で扱う際は、メソッド開始時に必ずリセットするか、局所変数へ置き換えてスレッド間の状態干渉を防止してください。",
  "model_used": "gpt-5-codex"
}