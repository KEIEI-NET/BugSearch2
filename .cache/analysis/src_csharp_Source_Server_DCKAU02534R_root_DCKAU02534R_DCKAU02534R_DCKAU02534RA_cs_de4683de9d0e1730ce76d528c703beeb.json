{
  "path": "src/csharp/Source/Server/DCKAU02534R.root/DCKAU02534R/DCKAU02534R/DCKAU02534RA.cs",
  "severity": 15,
  "problems": [],
  "original_code": "using System;\nusing System.Collections;\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Text;\nusing Broadleaf.Application.Remoting.ParamData;\nusing Broadleaf.Library.Resources;\nusing Broadleaf.Library.Data;\nusing Broadleaf.Library.Data.SqlTypes;\nusing Broadleaf.Library.Data.SqlClient;\nusing Broadleaf.Xml.Serialization;\nusing Broadleaf.Application.Resources;\n\nnamespace Broadleaf.Application.Remoting\n{\n    /// <summary>\n    /// \\\\DB[gIuWFNg\n    /// </summary>\n    /// <remarks>\n    /// <br>Note       : \\\\̎f[^sNXłB</br>\n    /// <br>Programmer : 980081 Rc F</br>\n    /// <br>Date       : 2007.11.15</br>\n    /// <br></br>\n    /// <br>Update Note: 2007.12.28  Rc F</br>\n    /// <br>             S_IɑS_WvĂ̂C</br>\n    /// <br>             wƉ\\w肪99̏ꍇ͑SΏۂɏC(ȑO28ȍ~)</br>\n    /// <br>             wE\\wǉ</br>\n    /// <br></br>\n    /// <br>Update Note: 2008.08.08 20081</br>\n    /// <br>             ol.mrpɕύX</br>\n    /// <br></br>\n    /// <br>Update Note: 2009.04.30 22008 </br>\n    /// <br>  ",
  "analysis": "## 1. 問題の詳細分析\n\n1. **SQLインジェクションの脆弱性（危険度：高）**  \n   `SearchCollectProgramProc` および `SearchDepsitMainProc` では、`ExtrInfo_CollectPlanWork` から受け取った値をそのまま SQL 文字列に連結して検索条件を構築しています。外部から渡された値にシングルクォートなどの特殊文字を混在させると、任意の SQL を実行できてしまう可能性があり、情報漏えいやデータ改ざんにつながります。危険度スコア 15 の最大要因がこれです。\n\n2. **リソースリークの可能性（危険度：中）**  \n   `SqlConnection` や `SqlCommand`、`SqlDataReader` の破棄を手動で行っており、例外経路によっては `Dispose()` が呼ばれないままリソースが保持される可能性があります。これはパフォーマンス低下や接続枯渇につながります。\n\n3. **例外処理が曖昧（危険度：低〜中）**  \n   例外が発生した場合にログ出力のみでエラー内容が呼び出し側へ十分に伝搬していません。また、どの入力値が原因だったかといったトレース情報の不足により、運用時の調査が難しくなります。\n\n---\n\n## 2. 改善コード\n\n### Before（問題のあるコード）\n```csharp\nStringBuilder sql = new StringBuilder();\nsql.Append(\"SELECT ...\");\nsql.Append(\" WHERE CPW.CUST_CD = '\" + extrInfo_CollectPlanWork.CustomerCode + \"'\");\nsql.Append(\"   AND CPW.APPLY_DATE >= '\" + extrInfo_CollectPlanWork.ApplyDateFrom + \"'\");\nsql.Append(\"   AND CPW.APPLY_DATE <= '\" + extrInfo_CollectPlanWork.ApplyDateTo + \"'\");\n\nusing (SqlCommand command = new SqlCommand(sql.ToString(), sqlConnection))\n{\n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // ・・・\n        }\n    }\n}\n```\n\n### After（改善後のコード）\n```csharp\nconst string baseSql = @\"\n    SELECT  /* 必要な列 */\n    FROM    CollectPlanWork CPW\n    WHERE   CPW.CUST_CD = @CustomerCode\n        AND CPW.APPLY_DATE BETWEEN @ApplyDateFrom AND @ApplyDateTo\";\n\nusing (SqlCommand command = new SqlCommand(baseSql, sqlConnection))\n{\n    command.Parameters.Add(\"@CustomerCode\", SqlDbType.NVarChar, 12)\n                      .Value = extrInfo_CollectPlanWork.CustomerCode ?? string.Empty;\n\n    command.Parameters.Add(\"@ApplyDateFrom\", SqlDbType.Date)\n                      .Value = extrInfo_CollectPlanWork.ApplyDateFrom ?? (object)DBNull.Value;\n\n    command.Parameters.Add(\"@ApplyDateTo\", SqlDbType.Date)\n                      .Value = extrInfo_CollectPlanWork.ApplyDateTo ?? (object)DBNull.Value;\n\n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // ・・・\n        }\n    }\n}\n```\n\n### Before（リソース制御の問題）\n```csharp\nSqlConnection sqlConnection = null;\ntry\n{\n    sqlConnection = CreateSqlConnection();\n    sqlConnection.Open();\n\n    status = SearchCollectProgramProc(ref retList, extrInfo_CollectPlanWork, ref sqlConnection);\n    status = SearchDepsitMainProc(ref retList, extrInfo_CollectPlanWork, ref sqlConnection);\n}\nfinally\n{\n    if (sqlConnection != null)\n    {\n        sqlConnection.Close();\n        sqlConnection.Dispose();\n    }\n}\n```\n\n### After（改善後のコード）\n```csharp\nusing (SqlConnection sqlConnection = CreateSqlConnection())\n{\n    if (sqlConnection == null)\n    {\n        retObj = new ArrayList();\n        return (int)ConstantManagement.MethodResult.ctFNC_ERROR;\n    }\n\n    sqlConnection.Open();\n\n    status = SearchCollectProgramProc(retList, extrInfo_CollectPlanWork, sqlConnection);\n    status = SearchDepsitMainProc(retList, extrInfo_CollectPlanWork, sqlConnection);\n}\n```\n\n### Before（例外処理）\n```csharp\ncatch (Exception ex)\n{\n    base.WriteErrorLog(ex, \"CollectProgramDB.SearchCollectProgram\");\n    retObj = new ArrayList();\n    return (int)ConstantManagement.MethodResult.ctFNC_ERROR;\n}\n```\n\n### After（改善後の例外処理）\n```csharp\ncatch (SqlException ex)\n{\n    base.WriteErrorLog(ex, \"CollectProgramDB.SearchCollectProgram\");\n    retObj = new ArrayList();\n    throw new DataAccessException(\"集金プログラム検索処理で SQL エラーが発生しました。\", ex);\n}\ncatch (Exception ex)\n{\n    base.WriteErrorLog(ex, \"CollectProgramDB.SearchCollectProgram\");\n    retObj = new ArrayList();\n    throw;\n}\n```\n\n---\n\n## 3. 追加の改善提案\n\n- **戻り値の型安全化**  \n  `ArrayList` ではなく `List<RsltInfo_CollectPlanWork>` のようにジェネリック型を採用すると、キャストミスを防げます。\n  \n- **入力値の検証**  \n  `ExtrInfo_CollectPlanWork` の各値に対し、長さやフォーマットの検証をメソッド冒頭で実施すると、SQL 例外の予防やログからの原因特定が容易になります。\n\n- **命名・責務の整理**  \n  `SearchCollectProgramProc` と `SearchDepsitMainProc` の責務が似ている場合は共通化し、SQL ビルドとマッピング部分を切り出すと可読性と保守性が向上します。\n\n- **暗号化機能の再検討**  \n  コメントアウトされている `SqlEncryptInfo` は本来暗号化列を扱うための仕組みと思われます。必要であれば復活させるか、Transparent Data Encryption など別の手段を採用してください。\n\nこれらの修正により、SQL インジェクションの排除と安定したリソース管理が実現し、アプリケーションの安全性と信頼性が向上します。",
  "model_used": "gpt-5-codex"
}