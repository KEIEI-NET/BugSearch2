{
  "path": "src/csharp/Source/Client/PMUOE00001C.root/PMUOE00001C/SYSTRIM.C",
  "severity": 19,
  "problems": [],
  "original_code": "/***********************************************************************/\n/*\tsystem\t\t\t: p[c} WVXe\t\t\t\t\t\t\t   */\n/*\tlibrary name\t: PMSYS.LIB  SYSTEM ʃCu\t\t\t   \t   */\n/*\tfile name\t\t: PMSYS.C\t\t\t\t\t\t\t\t\t\t   */\n/*\tprogramer\t\t: 񓡁@h\t\t\t\t\t\t\t\t\t   */\n/*\tdate\t\t\t: 1993-10-12\t\t\t\t\t\t\t\t\t   */\n/*---------------------------------------------------------------------*/\n/*\tP980812\tԗT\tRQrbgΉ\t\t\t\t\t\t\t  \t   */\n/*---------------------------------------------------------------------*/\n/*\t\t\tCopyright 1993 Hokkaido Tsubasa Software Lab. Co.\t\t   */\n/***********************************************************************/\n\n//#include\t\"sysdef.h\"\n//#include\t\"common.h\"\n#include \t<conio.h>\n#include \t<ctype.h>\n#include \t<dos.h>\n#include \t<stdio.h>\n#include \t<stdlib.h>\n#include \t<string.h>\n#include\t<mbstring.h>\n\nstatic char work_string[256];\n\n/***********************************************************************/\n/*\tmodule name : ̎woCgڂ̊`FbN\t\t\t\t   */\n/*\tmodule id\t: st_ktest\t\t\t\t\t\t\t\t\t\t   \t   */\n/*\treturn code : OFȊOAPF\t\t\t\t\t\t   \t",
  "analysis": "## 1. 問題の詳細分析\n1. **固定長グローバルバッファによるオーバーフローの危険**  \n   - 全関数で共有している `static char work_string[256]` に対し、入力文字列長の検証なしに `memmove`/`memcpy`/`strcat` を実行しており、256バイトを超える入力で簡単にバッファオーバーフローが発生します。特に `ltrim` は `strlen(str)` が 255 を超えると即座に書き込み範囲外へアクセスします。  \n   - グローバルバッファを共有しているため、並行呼び出し時にはデータ競合や内容破壊も起こり得ます。\n\n2. **`st_ktest` の境界チェック不足による不正メモリアクセス**  \n   - `pos` が文字列終端以降を指していても `_ismbblead(*(str + st_cnt))` を呼び出すため、終端の先を読み込んで未定義動作を招きます。  \n   - `pos` が負値の場合のチェックもないため、符号付き短整数から符号なしへの暗黙変換で想定外の領域を参照する危険があります。\n\n3. **`st_make` の負値や範囲外 `len` 取り扱いミス**  \n   - `len` が負値でもチェックされず、`memcpy` の第3引数に負値（符号なしへ変換され巨大値）を渡すことでオーバーフローを誘発します。  \n   - `len > 255` のときはエラーメッセージをセットしますが、それ以外の長さの場合にも入力文字列の長さ検証がなく、255超の入力をそのまま `memcpy` してしまうため危険です。\n\n4. **`st_rep` の長さ計算オーバーフローと負の `rep` による無限ループ**  \n   - `strlen(str) * rep` の検査は `int` 同士の乗算であり、乗算結果がオーバーフローした時点で境界チェックが無効化されます。  \n   - `rep` が負の場合 `while(rep--)` が終了しないため、無限ループになります。\n\n5. **`rtrim`／`st_rep` の未初期化領域・未定義動作の可能性**  \n   - `st_rep` の `memset(work_string, 0x00, 255)` は 255 バイトしか初期化せず、末尾の 1 バイトが以前の値のまま残る可能性があります。  \n   - `_mbsrev` での反転により多バイト文字列の整合性を損ねる危険があるため、マルチバイト文字対応の安全なトリム処理が必要です。\n\n---\n\n## 2. 改善コード\n### Before（問題のあるコード）\n```c\nstatic char work_string[256];\n\nchar *ltrim( char *str ){\n\tshort  length;\n\tchar c;\n\tchar *save;\n\tsave = str;\n\tfor(;;){\n\t\tc = *str;\n\t\tif( !c ) break;\n\t\tif( _ismbblead(c) ){\n\t\t\tif( c != 0x81 || *(str+1) != 0x40 ) break;\n\t\t\tstr++;\n\t\t}else{\n\t\t\tif( c != ' ' ) break;\n\t\t}\n\t\tstr++;\n\t}\n\tlength = strlen(str);\n\tmemmove( work_string, str, length );\n\twork_string[length] = 0x00;\n\tmemmove( save, work_string, length+1 );\n\treturn save;\n}\n\nchar *rtrim( char *str ){\n\tif( work_string != str ) strcpy( work_string, str );\n\t_mbsrev(work_string);\n\tltrim(work_string);\n\t_mbsrev(work_string);\n\tif( work_string != str ) strcpy( str, work_string);\n\treturn str;\n}\n\nchar *st_make( char *str, short len){\n\tshort  wklen;\n\tif( len > 255){\n\t\tstrcpy( work_string, \"String too long!!\" );\n\t}else{\n\t\tmemset( work_string, ' ', 255);\n\t\twklen = strlen( str );\n\t\tif( wklen > len ) wklen = len;\n\t\tif( wklen ) memcpy( work_string, str, wklen );\n\t\tif( st_ktest( work_string,(short)(len - 1) ) ) work_string[len-1] = ' ';\n\t\twork_string[len] = 0x00;\n\t}\n\treturn work_string;\n}\n\nchar *st_rep( char *str, short rep){\n\tif( (strlen(str) * rep) > 255 ){\n\t\tstrcpy( work_string, \"String repeat too long!!\" );\n\t}else{\n\t\tmemset( work_string, 0x00, 255);\n\t\tif( rep ) while( rep-- ) strcat( work_string, str );\n\t}\n\treturn work_string;\n}\n```\n\n### After（改善後のコード）\n```c\n#define WORK_STRING_SIZE 256\nstatic char work_string[WORK_STRING_SIZE];\n#define FULLWIDTH_SPACE_LEAD  0x81\n#define FULLWIDTH_SPACE_TRAIL 0x40\n\nshort st_ktest(const char *str, short pos)\n{\n\tif (str == NULL || pos < 0) {\n\t\treturn 0;\n\t}\n\n\tsize_t len = strlen(str);\n\tif ((size_t)pos >= len) {\n\t\treturn 0;\n\t}\n\n\tfor (size_t i = 0; i < len; ) {\n\t\tunsigned char ch = (unsigned char)str[i];\n\t\tif (_ismbblead(ch)) {\n\t\t\tif (i == (size_t)pos) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (i + 1 >= len) {\n\t\t\t\tbreak; /* 不完全なマルチバイト文字 */\n\t\t\t}\n\t\t\ti += 2;\n\t\t} else {\n\t\t\tif (i == (size_t)pos) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\t}\n\treturn 0;\n}\n\nchar *ltrim(char *str)\n{\n\tif (str == NULL) {\n\t\treturn NULL;\n\t}\n\n\tunsigned char *p = (unsigned char *)str;\n\n\twhile (*p != '\\0') {\n\t\tif (_ismbblead(*p)) {\n\t\t\tif (*(p + 1) == '\\0') {\n\t\t\t\tbreak; /* 途中で途切れたマルチバイト文字 */\n\t\t\t}\n\t\t\tif (*p == FULLWIDTH_SPACE_LEAD && *(p + 1) == FULLWIDTH_SPACE_TRAIL) {\n\t\t\t\tp += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (*p == ' ') {\n\t\t\t++p;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((char *)p != str) {\n\t\tmemmove(str, p, strlen((const char *)p) + 1);\n\t}\n\treturn str;\n}\n\nchar *rtrim(char *str)\n{\n\tif (str == NULL) {\n\t\treturn NULL;\n\t}\n\n\tunsigned char *p = (unsigned char *)str;\n\tunsigned char *last_non_space = NULL;\n\n\twhile (*p != '\\0') {\n\t\tif (_ismbblead(*p)) {\n\t\t\tif (*(p + 1) == '\\0') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(*p == FULLWIDTH_SPACE_LEAD && *(p + 1) == FULLWIDTH_SPACE_TRAIL)) {\n\t\t\t\tlast_non_space = p + 2;\n\t\t\t}\n\t\t\tp += 2;\n\t\t} else {\n\t\t\tif (*p != ' ') {\n\t\t\t\tlast_non_space = p + 1;\n\t\t\t}\n\t\t\t++p;\n\t\t}\n\t}\n\n\tif (last_non_space != NULL) {\n\t\t*last_non_space = '\\0';\n\t} else {\n\t\t*str = '\\0';\n\t}\n\treturn str;\n}\n\nstatic void set_error_message(const char *msg)\n{\n\tif (msg == NULL) {\n\t\twork_string[0] = '\\0';\n\t\treturn;\n\t}\n\tstrncpy(work_string, msg, WORK_STRING_SIZE - 1);\n\twork_string[WORK_STRING_SIZE - 1] = '\\0';\n}\n\nchar *st_make(const char *str, short len)\n{\n\tif (str == NULL || len < 0 || len >= WORK_STRING_SIZE) {\n\t\tset_error_message(\"String too long!!\");\n\t\treturn work_string;\n\t}\n\n\tmemset(work_string, ' ', (size_t)len);\n\twork_string[len] = '\\0';\n\n\tsize_t src_len = strlen(str);\n\tif (src_len > (size_t)len) {\n\t\tsrc_len = (size_t)len;\n\t}\n\n\tif (src_len > 0) {\n\t\tmemcpy(work_string, str, src_len);\n\t}\n\n\tif (len > 0 && st_ktest(work_string, (short)(len - 1))) {\n\t\twork_string[len - 1] = ' ';\n\t}\n\n\treturn work_string;\n}\n\nchar *st_rep(const char *str, short rep)\n{\n\tif (str == NULL || rep <= 0) {\n\t\twork_string[0] = '\\0';\n\t\treturn work_string;\n\t}\n\n\tsize_t unit_len = strlen(str);\n\tif (unit_len == 0) {\n\t\twork_string[0] = '\\0';\n\t\treturn work_string;\n\t}\n\n\tsize_t repetitions = (size_t)rep;\n\tif (unit_len > (WORK_STRING_SIZE - 1) / repetitions) {\n\t\tset_error_message(\"String repeat too long!!\");\n\t\treturn work_string;\n\t}\n\n\tchar *dest = work_string;\n\tfor (size_t i = 0; i < repetitions; ++i) {\n\t\tmemcpy(dest, str, unit_len);\n\t\tdest += unit_len;\n\t}\n\t*dest = '\\0';\n\treturn work_string;\n}\n```\n\n---\n\n## 3. 追加の改善提案\n- **再入性の確保**：現状は共有バッファを返す構造のため並行呼び出しができません。呼び出し側でバッファを渡す形式にAPIを変更するか、スレッドローカルや動的メモリ確保を利用するとさらに安全です。\n- **入力検証の徹底**：NULLポインタの早期検査・エラーハンドリングを統一し、エラーコードの返却やログ出力を導入すると保守性が向上します。\n- **ユニットテストの整備**：マルチバイト文字、長大文字列、エラーケースを網羅するテストを追加して安全性を担保してください。\n- **定数の明示化**：魔法値だった `0x81/0x40` をマクロ化しましたが、シフトJIS固有値であることをコメント等で明示すると可読性が向上します。\n- **ヘッダーの整理**：未使用ヘッダー（`dos.h` など）の削除やプラットフォーム依存APIのラップを検討し、移植性を高めましょう。",
  "model_used": "gpt-5-codex"
}