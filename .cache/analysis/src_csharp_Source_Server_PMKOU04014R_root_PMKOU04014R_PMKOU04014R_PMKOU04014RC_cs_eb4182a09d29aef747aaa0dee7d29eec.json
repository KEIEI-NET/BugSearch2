{
  "path": "src/csharp/Source/Server/PMKOU04014R.root/PMKOU04014R/PMKOU04014R/PMKOU04014RC.cs",
  "severity": 15,
  "problems": [],
  "original_code": "using System;\nusing System.Collections;\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Text;\nusing Broadleaf.Application.Remoting.ParamData;\nusing Broadleaf.Library.Resources;\nusing Broadleaf.Library.Data;\nusing Broadleaf.Library.Data.SqlTypes;\nusing Broadleaf.Library.Data.SqlClient;\nusing Broadleaf.Xml.Serialization;\nusing Broadleaf.Application.Resources;\nusing Broadleaf.Library.Globarization;\n\nnamespace Broadleaf.Application.Remoting\n{\n    /// <summary>\n    /// </summary>\n    /// <remarks>\n    /// <br>Update Note: 2009/09/08 ̕</br>\n    /// <br>           : PM.NS-2-BEolDmrێ˗@</br>\n    /// <br>           : ߋ\\Ή</br>\n    /// <br></br>\n    /// <br>Update Note: 2010/05/10 n</br>\n    /// <br>           : x`[jO</br>\n    /// <br>Update Note: 2011/11/29 yangmj redmine#8195 ddqɓӐR[hƗ̂̕ύX</br>\n    /// <br>Update Note: 2011/12/09 </br>\n    /// <br>           : Redmine#8195 ddqɓӐR[hƗ̂̕ύX</br>\n    /// <br>Update Note: 2012/06/26 20008 ɓ L</br>\n    /// <br>           : READUNCOMMITTEDΉ",
  "analysis": "## 1. 問題の詳細分析\n1. **SQLインジェクションの危険性（高）**  \n   `MakeTypeStcSlpQuery` / `MakeTypeStcSlpQuery2` / `MakeTypePaySlpQuery` / `MakeTypeStcSlpOdrQuery` などで、`SuppPrtPprWork` から渡される値をそのまま SQL 文字列へ連結しています。  \n   これらの値はリモーティング経由でクライアントから送られて来るため、悪意のある文字列（例: `' OR 1=1 --`）を挿入されると任意のデータ抽出や改ざんが可能です。特に `IN` 句や `BETWEEN` 条件を組み立てている箇所でも同様に危険で、標的となる列名・レコードを攻撃者が自由に操作できる状態になっています。\n\n2. **SQLCommand へのパラメータ不足（中）**  \n   `SqlCommand` オブジェクトを受け取っていますが、実際には `Parameters` を一切追加しておらず、コマンドテキストも戻り値として渡すだけになっています。そのため、SQL 実行時にパラメータ化ができず、上記 SQL インジェクションの危険性がさらに高まっています。\n\n3. **条件式の組み立てロジックが複雑化し、保守性が低い（中）**  \n   多数の if 文で文字列連結を繰り返しており、条件追加のたびに SQL 文字列へ直接手を入れる必要があります。SQL の可読性が低下し、将来的な機能追加・修正でバグや脆弱性を誘発しやすくなっています。\n\n## 2. 改善コード\n### Before（問題のあるコード）\n```csharp\nif (!string.IsNullOrEmpty(_suppPrtPprWork.SupplierCode))\n{\n    sbSql.Append(\" AND A.SUPPLIER_CODE = '\");\n    sbSql.Append(_suppPrtPprWork.SupplierCode);   // ← 直接連結\n    sbSql.Append(\"'\");\n}\n\nif (_suppPrtPprWork.SupplierFormal != null && _suppPrtPprWork.SupplierFormal.Length > 0)\n{\n    sbSql.Append(\" AND A.SUPPLIER_FORMAL IN (\");\n    sbSql.Append(string.Join(\",\", _suppPrtPprWork.SupplierFormal));  // ← 直接連結\n    sbSql.Append(\")\");\n}\n```\n\n### After（改善後のコード）\n```csharp\nif (!string.IsNullOrEmpty(_suppPrtPprWork.SupplierCode))\n{\n    sbSql.Append(\" AND A.SUPPLIER_CODE = @SupplierCode\");\n    sqlCommand.Parameters.Add(\"@SupplierCode\", SqlDbType.VarChar, 20)\n               .Value = _suppPrtPprWork.SupplierCode;\n}\n\nif (_suppPrtPprWork.SupplierFormal != null && _suppPrtPprWork.SupplierFormal.Length > 0)\n{\n    var parameterNames = new List<string>();\n    for (int i = 0; i < _suppPrtPprWork.SupplierFormal.Length; i++)\n    {\n        string parameterName = $\"@SupplierFormal{i}\";\n        parameterNames.Add(parameterName);\n        sqlCommand.Parameters.Add(parameterName, SqlDbType.Int).Value = _suppPrtPprWork.SupplierFormal[i];\n    }\n\n    sbSql.Append($\" AND A.SUPPLIER_FORMAL IN ({string.Join(\",\", parameterNames)})\");\n}\n```\n\n> ※ 上記は代表例です。同ファイル内で条件を連結している箇所すべてを同様に修正し、  \n> `BETWEEN`, `LIKE`, `IN`, `ORDER BY` などに使う値も完全にパラメータ化してください。\n\n## 3. 追加の改善提案\n- **`SqlCommand` の利用方法を統一**  \n  文字列を戻り値で返すのではなく、`SqlCommand.CommandText` に直接設定し、`Parameters` も同メソッド内で完結させる設計にすると安全かつ保守しやすいです。\n\n- **`IN` 句や `ORDER BY` の動的な列指定に対するバリデーション**  \n  列名・ソート順をクライアントから指定させる場合は、サーバー側で許可リスト（ホワイトリスト）チェックを行い、不正な列名・キーワードを排除してください。\n\n- **`READ UNCOMMITTED` (`NOLOCK`) の見直し**  \n  データ不整合やダーティリードの危険があるため、業務要件を再確認し、必要最低限の範囲のみ使用するか、極力排除することを推奨します。\n\n- **テストの追加**  \n  パラメータ化後も期待通りの SQL が生成されるか、ユニットテストや統合テストを追加し、攻撃パターン（`' OR 1=1 --` など）で挙動を確認してください。\n\n以上の修正により、SQL インジェクションのリスクを大幅に低減し、コードの可読性・保守性も向上します。",
  "model_used": "gpt-5-codex"
}