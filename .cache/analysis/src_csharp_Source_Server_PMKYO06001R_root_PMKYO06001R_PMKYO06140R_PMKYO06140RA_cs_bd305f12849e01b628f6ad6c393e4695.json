{
  "path": "src/csharp/Source/Server/PMKYO06001R.root/PMKYO06001R/PMKYO06140R/PMKYO06140RA.cs",
  "severity": 15,
  "problems": [],
  "original_code": "//****************************************************************************//\n// VXe         : PM.NS\n// vO   : }X^M\n// vOTv   : f[^Z^[ɑ΂ĒǉEXVs\n//----------------------------------------------------------------------------//\n//                (c)Copyright  2009 Broadleaf Co.,Ltd.\n//============================================================================//\n// \n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : \n//     2009/04/28  Ce : VK쐬\n//----------------------------------------------------------------------------//\n// Ǘԍ              CS : 杍^\n// C    2009/05/25  Ce : Ӑ}X^TBLCAEgύXɂC\n//----------------------------------------------------------------------------//\n// Ǘԍ              CS : \n// C    2009/06/12  Ce : public MethodSQLʖڑΉɂ\n//----------------------------------------------------------------------------//\n// Ǘԍ              CS :  r\n// C    2010/01/21  Ce : ^Cv̏o͍ڒǉiRځj\n//------------------------------------------------",
  "analysis": "## 1. 問題の詳細分析\n1. **SQL インジェクションの危険**  \n   `CreateSqlForSearch`（冒頭コメントの `myReaderDNX` で利用されている検索系メソッド）では、`CustomerCode` などリモート要求から受け取った値を文字列連結でそのまま SQL に差し込んでいます。悪意ある呼び出し元が `'; DROP TABLE ... --` のような文字列を渡せば、任意の SQL を実行でき、顧客情報の流出や破壊が発生します。\n\n2. **SqlDataReader のリソースリーク**  \n   `ExecuteCustomerQuery` では `SqlDataReader myReaderDNX = base.ExecuteReader(sql.ToString());` のように `SqlDataReader` を生成した後、例外経路で `Close()` が呼ばれません。`SqlDataReader` を閉じないとコネクションプールの枯渇や、後続処理のハングにつながります。\n\n3. **列オーディナルの脆弱な扱い**  \n   `_indexAName = reader.GetOrdinal(\"NAME\");` など多数の列インデックスを取得していますが、例外処理や列存在チェックがなくスキーマ変更に極端に弱い構造です。列が欠けたり別名になった場合、`IndexOutOfRangeException` が発生しプロセス全体が停止します。\n\n## 2. 改善コード\n### Before（問題のあるコード）\n```csharp\n// SQL文字列への危険な連結\nsql.Append(\"    AND A.CUSTOMER_CODE = '\" + param.CustomerCode + \"'\");\nsql.Append(\"    AND (A.NAME LIKE '%\" + param.CustomerName + \"%' OR A.KANA LIKE '%\" + param.CustomerKana + \"%')\");\nsql.Append(\"    AND (A.HOME_TEL_NO = '\" + param.Tel + \"' OR A.PORTABLE_TEL_NO = '\" + param.Tel + \"')\");\n\n// SqlDataReader を閉じていない\nSqlDataReader myReaderDNX = base.ExecuteReader(sql.ToString());\nwhile (myReaderDNX.Read())\n{\n    // ... 省略 ...\n}\nmyReaderDNX.Close(); // ← try/catch の中で例外が出ると Close() されない\n\n// 列定義を盲目的に使用\n_indexAName = myReaderDNX.GetOrdinal(\"NAME\");\ncustomer.Name = myReaderDNX.GetString(_indexAName);  // 列が欠けると例外\n```\n\n### After（改善後のコード）\n```csharp\n// パラメータ化された SQL を組み立てる\nsql.AppendLine(\"AND A.CUSTOMER_CODE = @CustomerCode\");\nsql.AppendLine(\"AND (A.NAME LIKE @CustomerName OR A.KANA LIKE @CustomerKana)\");\nsql.AppendLine(\"AND (A.HOME_TEL_NO = @Tel OR A.PORTABLE_TEL_NO = @Tel)\");\n\nusing (var command = new SqlCommand(sql.ToString(), connection))\n{\n    command.Parameters.Add(\"@CustomerCode\", SqlDbType.VarChar, 20).Value = param.CustomerCode ?? (object)DBNull.Value;\n    command.Parameters.Add(\"@CustomerName\", SqlDbType.NVarChar, 100).Value = $\"%{param.CustomerName ?? string.Empty}%\";\n    command.Parameters.Add(\"@CustomerKana\", SqlDbType.NVarChar, 100).Value = $\"%{param.CustomerKana ?? string.Empty}%\";\n    command.Parameters.Add(\"@Tel\", SqlDbType.VarChar, 20).Value = param.Tel ?? (object)DBNull.Value;\n\n    using (var reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            int nameOrdinal = SafeGetOrdinal(reader, \"NAME\");\n            if (nameOrdinal >= 0)\n            {\n                customer.Name = reader.IsDBNull(nameOrdinal) ? string.Empty : reader.GetString(nameOrdinal);\n            }\n            // ... 他列も同様に安全にアクセス ...\n        }\n    }\n}\n\n// 列存在チェックを行うユーティリティ\nprivate static int SafeGetOrdinal(SqlDataReader reader, string columnName)\n{\n    try\n    {\n        return reader.GetOrdinal(columnName);\n    }\n    catch (IndexOutOfRangeException)\n    {\n        Trace.TraceWarning($\"Column '{columnName}' was not found in result set.\");\n        return -1;\n    }\n}\n```\n\n## 3. 追加の改善提案\n- SQL の構築処理を別メソッドに切り出し、`SqlCommand` と `SqlParameter` を戻り値として返すようにすれば、メンテナンスが容易になります。\n- 列インデックスを大量に保持する代わりに、`reader.GetFieldValue<T>(\"NAME\")` のような名前ベースの API を用いることで、スキーマ変更に柔軟に対応できます。\n- 例外発生時のログ出力とユーザーへの戻り値（エラーコード）を統一し、異常時でもシステムが予期せぬ停止を起こさないようガード句を追加しましょう。\n- DTO（データ転送オブジェクト）を導入して DataReader→DTO のマッピングを一箇所にまとめ、重複する列マッピング処理を削減すると保守性が大幅に向上します。",
  "model_used": "gpt-5-codex"
}