{
  "path": "src/csharp/Source/Server/PMSCM09024R.root/PMSCM09024R/PMSCM09024R/PMSCM09024RA.cs",
  "severity": 18,
  "problems": [],
  "original_code": "using System;\nusing System.Collections;\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Text;\nusing Broadleaf.Application.Remoting.ParamData;\nusing Broadleaf.Library.Resources;\nusing Broadleaf.Library.Data;\nusing Broadleaf.Library.Data.SqlTypes;\nusing Broadleaf.Library.Data.SqlClient;\nusing Broadleaf.Xml.Serialization;\nusing Broadleaf.Application.Resources;\n\nnamespace Broadleaf.Application.Remoting\n{\n    /// <summary>\n    /// SCMS̐ݒ}X^DB[gIuWFNg\n    /// </summary>\n    /// <remarks>\n    /// <br>Note       : SCMS̐ݒ}X^̎f[^sNXłB</br>\n    /// <br>Programmer : 30350@N@</br>\n    /// <br>Date       : 2009.04.27</br>\n    /// <br></br>\n    /// <br>Update Note      :   2012/08/31  30747 O L</br>\n    /// <br>                 :   ڒǉ </br>\n    /// <br>                 :   񓚎\\敪(2012/10zM\\ SCMQ76̑Ή)</br>\n    /// <br></br>\n    /// <br>Update Note      :   2012/11/09  30744  q</br>\n    /// <br>                 :   ڒǉ </br>\n    /// <br>                 :     񓚋敪i⍇jA񓚋敪ijA</br>\n    /// <br>     ",
  "analysis": "## 1. 問題の詳細分析\n\n1. **`SqlConnection` を手動でクローズしており例外時にリークするリスク（DoS）**  \n   `Search` メソッドでは `SqlConnection` を `Close/Dispose` で手動管理しています。  \n   例外が発生した場合は `finally` が動作するものの、将来の改修で `return`／`throw` が挿入されると簡単に漏洩させてしまう危険があります。接続が使い捨てられず枯渇すると、同一プロセス／同一DBを利用する他処理にも影響が波及し、事実上のサービス不可（DoS）になります。\n\n2. **パラメータを `object`→`ArrayList`/`SCMTtlStWork` にキャストしており不正値をそのまま許容（SQLインジェクション誘発リスク）**  \n   `SearchSCMTtlStProc` では `parascmTtlStWork` を `ArrayList` または `SCMTtlStWork` として扱っていますが、型検証・サニタイズが無いため、予期しない型や任意文字列を仕込めます。  \n   下位で SQL を組み立てる処理が文字列連結に依存していると、攻撃者が `ArrayList` に細工した値を入れるだけで SQL インジェクション（権限昇格・情報漏洩）を誘発します。少なくとも入力型を厳格に限定し、値は必ず SqlParameter を経由させるべきです。\n\n3. **`ref SqlConnection` の公開でライフサイクルが発散しやすい（予期せぬ多重Dispose）**  \n   `SearchSCMTtlStProc` が `ref SqlConnection` を受け取っており、呼び出し側の責務が不明確になっています。利用側がうっかり `Dispose`／`Close` したり、別の接続を再代入すると、以降の処理で `ObjectDisposedException` や「接続が既に開いている/閉じている」等の障害が発生する恐れがあります。  \n   DB リソースの寿命は所有者（ここでは `Search` メソッド）だけが管理する設計に改めたほうが安全です。\n\n## 2. 改善コード\n\n### Before（問題のあるコード）\n```csharp\npublic int Search(out object scmTtlStWork, object paraSCMTtlStWork, int readMode, ConstantManagement.LogicalMode logicalMode)\n{\n    int status = (int)ConstantManagement.DB_Status.ctDB_EOF;\n\n    SqlConnection sqlConnection = null;\n    scmTtlStWork = null;\n    try\n    {\n        sqlConnection = CreateSqlConnection();\n        if (sqlConnection == null) return status;\n        sqlConnection.Open();\n\n        return SearchSCMTtlStProc(out scmTtlStWork, paraSCMTtlStWork, readMode, logicalMode, ref sqlConnection);\n    }\n    catch (Exception ex)\n    {\n        base.WriteErrorLog(ex, \"SCMTtlStDB.Search\");\n        scmTtlStWork = new ArrayList();\n        return (int)ConstantManagement.MethodResult.ctFNC_ERROR;\n    }\n    finally\n    {\n        if (sqlConnection != null)\n        {\n            sqlConnection.Close();\n            sqlConnection.Dispose();\n        }\n    }\n}\n\npublic int SearchSCMTtlStProc(out object objscmTtlStWork, object parascmTtlStWork, int readMode, ConstantManagement.LogicalMode logicalMode, ref SqlConnection sqlConnection)\n{\n    SCMTtlStWork scmTtlStWork = null; \n\n    ArrayList stockmngttlstWorkList = parascmTtlStWork as ArrayList;\n    if (stockmngttlstWorkList == null)\n    {\n        scmTtlStWork = parascmTtlStWork as SCMTtlStWork;\n    }\n    ...\n```\n\n### After（改善後のコード）\n```csharp\npublic int Search(out object scmTtlStWork, object paraSCMTtlStWork, int readMode, ConstantManagement.LogicalMode logicalMode)\n{\n    scmTtlStWork = null;\n\n    try\n    {\n        using (var sqlConnection = CreateSqlConnection())\n        {\n            if (sqlConnection == null)\n            {\n                return (int)ConstantManagement.DB_Status.ctDB_EOF;\n            }\n\n            sqlConnection.Open();\n            return SearchSCMTtlStProc(out scmTtlStWork, paraSCMTtlStWork, readMode, logicalMode, sqlConnection);\n        }\n    }\n    catch (SqlException ex)\n    {\n        base.WriteErrorLog(ex, \"SCMTtlStDB.Search(SqlException)\");\n        scmTtlStWork = Array.Empty<SCMTtlStWork>();\n        return (int)ConstantManagement.MethodResult.ctFNC_ERROR;\n    }\n    catch (Exception ex)\n    {\n        base.WriteErrorLog(ex, \"SCMTtlStDB.Search\");\n        scmTtlStWork = Array.Empty<SCMTtlStWork>();\n        return (int)ConstantManagement.MethodResult.ctFNC_ERROR;\n    }\n}\n\npublic int SearchSCMTtlStProc(out object objscmTtlStWork, object parascmTtlStWork, int readMode, ConstantManagement.LogicalMode logicalMode, SqlConnection sqlConnection)\n{\n    if (parascmTtlStWork is null)\n    {\n        throw new ArgumentNullException(nameof(parascmTtlStWork));\n    }\n\n    IReadOnlyCollection<SCMTtlStWork> requestItems = parascmTtlStWork switch\n    {\n        IEnumerable enumerable when enumerable is IEnumerable<SCMTtlStWork> typed => typed.ToList(),\n        SCMTtlStWork singleItem => new[] { singleItem },\n        _ => throw new ArgumentException(\n            $\"Parameter {nameof(parascmTtlStWork)} must be SCMTtlStWork or IEnumerable<SCMTtlStWork>.\",\n            nameof(parascmTtlStWork))\n    };\n\n    using var command = sqlConnection.CreateCommand();\n    command.CommandType = CommandType.StoredProcedure;\n    command.CommandText = \"SCMTTLSTRF\";\n    command.Parameters.Clear();\n\n    command.Parameters.Add(\"@READ_MODE\", SqlDbType.Int).Value = readMode;\n    command.Parameters.Add(\"@LOGICAL_MODE\", SqlDbType.Int).Value = (int)logicalMode;\n    // ここで requestItems の各値をパラメータ化して追加する──文字列連結は禁止\n    AddWorkParameters(command, requestItems);\n\n    using var reader = command.ExecuteReader();\n    var result = new List<SCMTtlStWork>();\n    while (reader.Read())\n    {\n        result.Add(MapToWork(reader));\n    }\n\n    objscmTtlStWork = result;\n    return result.Count == 0\n        ? (int)ConstantManagement.DB_Status.ctDB_EOF\n        : (int)ConstantManagement.DB_Status.ctDB_SUCCESS;\n}\n\nprivate static void AddWorkParameters(SqlCommand command, IEnumerable<SCMTtlStWork> requestItems)\n{\n    // 例: requestItems の１件目だけを検索キーにする場合\n    var work = requestItems.First();\n    command.Parameters.Add(\"@SECTION_CODE\", SqlDbType.VarChar, 2).Value = work.SectionCode ?? \"00\";\n    command.Parameters.Add(\"@FROM_DATE\", SqlDbType.Date).Value = work.FromDate;\n    // ...必要なだけ追加\n}\n\nprivate static SCMTtlStWork MapToWork(SqlDataReader reader)\n{\n    return new SCMTtlStWork\n    {\n        SectionCode = reader.GetString(reader.GetOrdinal(\"SECTION_CODE\")),\n        FromDate = reader.GetDateTime(reader.GetOrdinal(\"FROM_DATE\")),\n        // ...必要な列を設定\n    };\n}\n```\n*ポイント*\n- `using` に置き換えて接続／コマンド／リーダを確実に破棄。\n- パラメータを強い型に限定（`SCMTtlStWork` or `IEnumerable<SCMTtlStWork>`）。\n- SQL は StoredProcedure + `SqlParameter` で構築（文字列連結禁止）。\n- 結果は `List<SCMTtlStWork>` を返し `ArrayList` を排除。\n\n## 3. 追加の改善提案\n\n1. **返却型の見直し**  \n   `object`／`ArrayList` ではなく `IReadOnlyList<SCMTtlStWork>` などに統一することで、呼び出し側のキャストミスを防ぎコンパイル時に型保証ができます。\n\n2. **例外粒度の細分化**  \n   `SqlException` と一般例外を分けましたが、さらに `TimeoutException`／`InvalidOperationException` 等でログや再試行の方針を変えられると堅牢になります。\n\n3. **CancellationToken 対応**  \n   大量アクセス時でも即座に処理を停止できるよう、`ExecuteReaderAsync` 等の async + `CancellationToken` 化を検討してください。\n\n4. **入力チェック／Audit ログ**  \n   ビジネス的に異常な条件（例: 期間の逆転、存在しないセクションコード）を早期に弾き、監査用ログを併用することで、不正アクセスの兆候を把握しやすくなります。",
  "model_used": "gpt-5-codex"
}