{
  "path": "src/csharp/Source/Server/PMKHN02605RC.root/PMKHN02605RC/PMKHN02605RC/PMKHN02605RCA.cs",
  "severity": 15,
  "problems": [],
  "original_code": "using System;\nusing System.Collections;\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Text;\nusing Broadleaf.Application.Remoting.ParamData;\nusing Broadleaf.Library.Resources;\nusing Broadleaf.Library.Data;\nusing Broadleaf.Library.Data.SqlTypes;\nusing Broadleaf.Library.Data.SqlClient;\nusing Broadleaf.Application.Resources;\nusing Broadleaf.Application.Common; //  ADD 2020/08/20  PMKOBETSU-4005\n\nnamespace Broadleaf.Application.Remoting\n{\n    /// <summary>\n    /// i}X^  [gIuWFNg\n    /// </summary>\n    /// <remarks>\n    /// <br>Note       : i}X^̎f[^sNXłB</br>\n    /// <br>Programmer : 23012  [N</br>\n    /// <br>Date       : 2008.11.11</br>\n    /// <br></br>\n    /// <br>Update Note: </br>\n    /// <br>Update Note: A 810 zhouyu </br>\n    /// <br>Date       : 2011/08/12 </br>\n    /// <br>UpdateNote : K2013/09/10 wangl2@t^oC</br>\n    /// <br>Ǘԍ   : 10902160-00</br>\n    /// <br>Update Note: PMKOBETSU-4005 dad΍</br>\n    /// <br>Programmer : </br>\n    /// <br>Date       : 2020/08/20</b",
  "analysis": "## 1. 問題の詳細分析\n\n1. **型検証の欠如によるサービス妨害リスク（危険度：中）**  \n   `Search`／`SearchGoodsPrt` は外部呼び出しに対して `object` 型の引数を直接受け取り、`ArrayList` へのキャストや `[0]` アクセスを前提にしています。リモート呼び出し側が想定外のオブジェクトを渡した場合、`InvalidCastException` や `NullReferenceException` が発生し、結果としてサービス停止（DoS）につながる恐れがあります。入力を明示的に検証し、型が不正な場合は早期リターンする必要があります。\n\n2. **接続リソース解放の記述が脆弱（危険度：低～中）**  \n   `SqlConnection` を `try`／`finally` でクローズする実装は一応動作しますが、今後コードが変更された際に `return` が追加されるなどすると解放漏れが再発しやすく、接続枯渇リスクが再燃します。`using` 文で `SqlConnection` を管理すれば、例外や早期リターンでも確実に解放され、保守性が向上します。\n\n3. **非ジェネリックコレクションの使用による可読性・安全性の低下（危険度：低）**  \n   `ArrayList` を使うとボックス化／アンボックス化や動的キャストが発生し、実装ミスに弱くなります。`List<T>` 等のジェネリックコレクションを用いれば、型安全性が担保され、保守性・性能が改善できます。\n\n## 2. 改善コード\n\n### Before（問題のあるコード）\n```csharp\npublic int Search(out object paraFutabaGoodsPrintResultWork, object paraFutabaGoodsPrintParamWork, ConstantManagement.LogicalMode logicalMode)\n{\n    int status = (int)ConstantManagement.DB_Status.ctDB_EOF;\n    SqlConnection sqlConnection = null;\n\n    paraFutabaGoodsPrintResultWork = null;\n\n    try\n    {\n        sqlConnection = CreateSqlConnection();\n        if (sqlConnection == null) return status;\n        sqlConnection.Open();\n\n        return SearchGoodsPrt(out paraFutabaGoodsPrintResultWork, paraFutabaGoodsPrintParamWork, logicalMode, ref sqlConnection);\n    }\n    catch (Exception ex)\n    {\n        base.WriteErrorLog(ex, \"FutabaGoodsPrintDB.Search\");\n        paraFutabaGoodsPrintResultWork = new ArrayList();\n        return (int)ConstantManagement.MethodResult.ctFNC_ERROR;\n    }\n    finally\n    {\n        if (sqlConnection != null)\n        {\n            sqlConnection.Close();\n            sqlConnection.Dispose();\n        }\n    }\n}\n\npublic int SearchGoodsPrt(out object paraFutabaGoodsPrintResultWork, object paraFutabaGoodsPrintParamWork, ConstantManagement.LogicalMode logicalMode, ref SqlConnection sqlConnection)\n{\n    FutabaGoodsPrintParamWork futabaGoodsPrintParamWork = null;\n\n    ArrayList futabaGoodsPrintParamWorkList = paraFutabaGoodsPrintParamWork as ArrayList;\n    ArrayList futabaGoodsPrintResultWorkList = new ArrayList();\n\n    if (futabaGoodsPrintParamWorkList == null)\n    {\n        futabaGoodsPrintParamWork = paraFutabaGoodsPrintParamWork as FutabaGoodsPrintParamWork;\n    }\n    else\n    {\n        if (futabaGoodsPrintParamWorkList.Count > 0)\n            futabaGoodsPrintParamWork = futabaGoodsPrintParamWorkList[0] as FutabaGoodsPrintParamWork;\n    }\n\n    int status = (int)ConstantManagement.DB_Status.ctDB_EOF;\n\n    try\n    {\n        // ...\n```\n\n### After（改善後のコード）\n```csharp\npublic int Search(\n    out object paraFutabaGoodsPrintResultWork,\n    object paraFutabaGoodsPrintParamWork,\n    ConstantManagement.LogicalMode logicalMode)\n{\n    paraFutabaGoodsPrintResultWork = null;\n    const int defaultStatus = (int)ConstantManagement.DB_Status.ctDB_EOF;\n\n    // ❶ 入力検証：期待する型以外が渡された場合は即座にエラー扱い\n    if (paraFutabaGoodsPrintParamWork is not FutabaGoodsPrintParamWork\n        && paraFutabaGoodsPrintParamWork is not IEnumerable<FutabaGoodsPrintParamWork>)\n    {\n        base.WriteErrorLog(new ArgumentException(\"Invalid parameter type.\"), \"FutabaGoodsPrintDB.Search\");\n        paraFutabaGoodsPrintResultWork = new List<FutabaGoodsPrintResultWork>();\n        return (int)ConstantManagement.MethodResult.ctFNC_ERROR;\n    }\n\n    try\n    {\n        using SqlConnection sqlConnection = CreateSqlConnection();\n        if (sqlConnection == null)\n        {\n            return defaultStatus;\n        }\n\n        sqlConnection.Open();\n        return SearchGoodsPrt(out paraFutabaGoodsPrintResultWork,\n                              paraFutabaGoodsPrintParamWork,\n                              logicalMode,\n                              sqlConnection);\n    }\n    catch (Exception ex)\n    {\n        base.WriteErrorLog(ex, \"FutabaGoodsPrintDB.Search\");\n        paraFutabaGoodsPrintResultWork = new List<FutabaGoodsPrintResultWork>();\n        return (int)ConstantManagement.MethodResult.ctFNC_ERROR;\n    }\n}\n\npublic int SearchGoodsPrt(\n    out object paraFutabaGoodsPrintResultWork,\n    object paraFutabaGoodsPrintParamWork,\n    ConstantManagement.LogicalMode logicalMode,\n    SqlConnection sqlConnection)\n{\n    // ❷ パラメータの扱いを型安全に\n    FutabaGoodsPrintParamWork futabaGoodsPrintParamWork = paraFutabaGoodsPrintParamWork switch\n    {\n        FutabaGoodsPrintParamWork single => single,\n        IEnumerable<FutabaGoodsPrintParamWork> enumerable => enumerable.FirstOrDefault(),\n        _ => null\n    };\n\n    if (futabaGoodsPrintParamWork == null)\n    {\n        paraFutabaGoodsPrintResultWork = new List<FutabaGoodsPrintResultWork>();\n        return (int)ConstantManagement.MethodResult.ctFNC_ERROR;\n    }\n\n    var futabaGoodsPrintResultWorkList = new List<FutabaGoodsPrintResultWork>();\n    int status = (int)ConstantManagement.DB_Status.ctDB_EOF;\n\n    try\n    {\n        using var command = sqlConnection.CreateCommand();\n        command.CommandText = \"dbo.PMKHN02607DC\"; // 例：ストアド名\n        command.CommandType = CommandType.StoredProcedure;\n\n        // ❸ パラメータは必ず SqlParameter を利用（SQL インジェクション防止）\n        command.Parameters.Add(new SqlParameter(\"@LogicalMode\", SqlDbType.Int)\n        {\n            Value = (int)logicalMode\n        });\n        command.Parameters.Add(new SqlParameter(\"@SomeParam\", SqlDbType.NVarChar, 50)\n        {\n            Value = futabaGoodsPrintParamWork.SomeProperty ?? string.Empty\n        });\n        // 他の必要なパラメータもここでバインド\n\n        using var reader = command.ExecuteReader();\n        while (reader.Read())\n        {\n            var result = new FutabaGoodsPrintResultWork\n            {\n                // reader から安全にマッピング\n            };\n            futabaGoodsPrintResultWorkList.Add(result);\n        }\n\n        status = futabaGoodsPrintResultWorkList.Count > 0\n            ? (int)ConstantManagement.DB_Status.ctDB_Normal\n            : (int)ConstantManagement.DB_Status.ctDB_EOF;\n    }\n    catch (Exception ex)\n    {\n        base.WriteErrorLog(ex, \"FutabaGoodsPrintDB.SearchGoodsPrt\");\n        futabaGoodsPrintResultWorkList.Clear();\n        status = (int)ConstantManagement.MethodResult.ctFNC_ERROR;\n    }\n\n    // ❹ 出力も List<T> として返しつつ互換性維持のため object に箱詰め\n    paraFutabaGoodsPrintResultWork = futabaGoodsPrintResultWorkList;\n    return status;\n}\n```\n\n*ポイント*  \n- `using` により `SqlConnection`／`SqlCommand`／`SqlDataReader` を確実に破棄。  \n- パラメータ型を検証し、想定外のものが来た場合は即座にエラーを返すことで DoS を防止。  \n- SQL 実行には必ず `SqlParameter` を利用し、将来の SQL インジェクションリスクを排除。  \n- `ArrayList` から `List<FutabaGoodsPrintResultWork>` に移行（外部 API 互換のため `object` で返却するが、中身は型安全）。\n\n## 3. 追加の改善提案\n\n- **入力パラメータの検証強化**  \n  呼び出し元から渡されるオブジェクトについて、プロパティ単位でも null／範囲チェックを行い、異常値を早期検知できるようにしてください。\n\n- **例外分類とログの詳細化**  \n  DB 接続エラー、パラメータ不備など例外を分類し、ログメッセージにシナリオ別の識別子を含めると障害解析が容易になります。\n\n- **ユニットテストの整備**  \n  正常系／異常系（型不一致、欠損パラメータなど）を網羅するテストを用意しておくと、将来のリグレッションを防げます。\n\n- **非同期 API への移行検討**  \n  長時間の DB 処理が予想される場合は `async`／`await` を活用した非同期実装にすると、サーバーのスレッド占有を抑えられます。\n\n以上の修正で、入力の安全性を高めると同時にリソースリーク防止と保守性向上が図れます。",
  "model_used": "gpt-5-codex"
}