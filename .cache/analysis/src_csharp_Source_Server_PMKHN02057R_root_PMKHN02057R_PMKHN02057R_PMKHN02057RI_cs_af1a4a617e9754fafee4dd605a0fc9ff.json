{
  "path": "src/csharp/Source/Server/PMKHN02057R.root/PMKHN02057R/PMKHN02057R/PMKHN02057RI.cs",
  "severity": 15,
  "problems": [],
  "original_code": "//****************************************************************************//\n// VXe         : .NSV[Y\n// vO   : Ly[ѕ\\\n// vOTv   : Ly[ѕ\\@̔敪ʗp\n//----------------------------------------------------------------------------//\n//                (c)Copyright  2011 Broadleaf Co.,Ltd.\n//============================================================================//\n// \n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : c\n//     2011/05/19  Ce : VK쐬\n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : \n//     2011/07/05  Ce : Redmine Q #22746 ̑Ή\n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : \n//     2011/07/07  Ce : Redmine dlA #22792 ̑Ή\n//----------------------------------------------------------------------------//\n// Ǘԍ              쐬S : \n//     2011/07/11  Ce : Redmine dlύX #22860 ̑Ή\n//------------------------------------------",
  "analysis": "## 1. 問題の詳細分析\n1. **SQLインジェクションの危険性（危険度：高）**  \n   `MakeSalesSelectStringProc` メソッドでは、`CampaignstRsltListPrtWork` から渡される条件値（例：`EnterpriseCode`, `ShopCode`, `CampaignCode` 等）を文字列連結で直接SQL文に差し込んでいます。この入力値は外部から届く可能性が高く、悪意ある値（例：`' OR 1=1 --`）を混入されると、データ改ざん・情報漏えい・認証回避など重大な被害につながります。`SqlCommand` を受け取っているにもかかわらずパラメータ化されていない点が根本原因です。\n\n2. **パラメータのクリア忘れによる副作用（危険度：中）**  \n   `SqlCommand` を `ref` で受け取り再利用する実装ですが、`MakeSalesSelectStringProc` 内で `Parameters.Clear()` が呼ばれていないため、前回の呼び出し時に追加した `SqlParameter` がそのまま残る可能性があります。異なる条件で呼び出した際に想定外のパラメータが付与され、結果が変わる・例外を誘発するといった不具合につながります。\n\n## 2. 改善コード\n### Before（問題のあるコード）\n```csharp\nprivate string MakeSalesSelectStringProc(ref SqlConnection sqlConnection,\n                                         ref SqlCommand sqlCommand,\n                                         CampaignstRsltListPrtWork CndtnWork)\n{\n    StringBuilder sbSql = new StringBuilder();\n    sbSql.Append(\"SELECT ... FROM ... WHERE 1 = 1 \");\n\n    if (!string.IsNullOrEmpty(CndtnWork.EnterpriseCode))\n    {\n        sbSql.Append(\" AND CMP.ENTERPRISE_CODE = '\" + CndtnWork.EnterpriseCode + \"'\");\n    }\n    if (!string.IsNullOrEmpty(CndtnWork.ShopCode))\n    {\n        sbSql.Append(\" AND CMP.SHOP_CODE = '\" + CndtnWork.ShopCode + \"'\");\n    }\n    if (!string.IsNullOrEmpty(CndtnWork.CampaignCode))\n    {\n        sbSql.Append(\" AND CMP.CAMPAIGN_CODE = '\" + CndtnWork.CampaignCode + \"'\");\n    }\n    // … さらに複数の入力値を直接連結 …\n\n    sqlCommand.CommandText = sbSql.ToString();\n    return sbSql.ToString();\n}\n```\n\n### After（改善後のコード）\n```csharp\nprivate string MakeSalesSelectStringProc(ref SqlConnection sqlConnection,\n                                         ref SqlCommand sqlCommand,\n                                         CampaignstRsltListPrtWork CndtnWork)\n{\n    // 事前に残っているパラメータをクリア\n    sqlCommand.Parameters.Clear();\n\n    StringBuilder sbSql = new StringBuilder();\n    sbSql.Append(\"SELECT ... FROM ... WHERE 1 = 1 \");\n\n    if (!string.IsNullOrEmpty(CndtnWork.EnterpriseCode))\n    {\n        sbSql.Append(\" AND CMP.ENTERPRISE_CODE = @EnterpriseCode\");\n        sqlCommand.Parameters.Add(\"@EnterpriseCode\", SqlDbType.VarChar, 12)\n                  .Value = CndtnWork.EnterpriseCode;\n    }\n\n    if (!string.IsNullOrEmpty(CndtnWork.ShopCode))\n    {\n        sbSql.Append(\" AND CMP.SHOP_CODE = @ShopCode\");\n        sqlCommand.Parameters.Add(\"@ShopCode\", SqlDbType.VarChar, 12)\n                  .Value = CndtnWork.ShopCode;\n    }\n\n    if (!string.IsNullOrEmpty(CndtnWork.CampaignCode))\n    {\n        sbSql.Append(\" AND CMP.CAMPAIGN_CODE = @CampaignCode\");\n        sqlCommand.Parameters.Add(\"@CampaignCode\", SqlDbType.VarChar, 20)\n                  .Value = CndtnWork.CampaignCode;\n    }\n\n    // … 以降の条件も同様にパラメータ化 …\n\n    sqlCommand.CommandText = sbSql.ToString();\n    return sbSql.ToString();\n}\n```\n\n## 3. 追加の改善提案\n- **`using` ブロックの活用**：`SqlConnection` や `SqlCommand` を都度 `using` で閉じる構造にすると、接続リークを防ぎながら可読性も向上します（現在は呼び出し側で管理する設計ですが、リファクタ余地があります）。\n- **入力値の前処理**：日付・数値・コード体系に応じた形式チェックや正規化を行い、早期に不正値を除外することで後段処理の安全性が高まります。\n- **`ArrayList` の廃止**：`GetFinYearTableGenerator` で `ArrayList` を使用していますが、ジェネリクスの `List<CompanyInfWork>` に置き換えることで型安全性と可読性を改善できます。\n- **例外処理の整備**：DBアクセス部分に try-catch を設け、ロギングや再スローを適切に行うことで異常時の原因追跡が容易になります。\n- **ユニットテスト追加**：SQL文字列生成メソッドに対するテストを用意し、危険な文字列が含まれていないか、期待するクエリが組み立てられているかを自動検証できるようにすると保守性が高まります。",
  "model_used": "gpt-5-codex"
}