# Oracle Database Antipatterns and Performance Issues
# Auto-generated by BugSearch2 - Database-Specific Rules
# Generated: 2025-10-14
# Category: database
# Target: Oracle Enterprise RDBMS

rule:
  id: ORACLE_ROW_BY_ROW_PLSQL
  category: database
  name: Oracle PL/SQL Row-by-Row Processing
  description: |
    PL/SQL loops processing row-by-row are extremely slow.
    Bulk operations (BULK COLLECT, FORALL) are 10-100x faster.

    Problems:
    - Context switching (SQL <-> PL/SQL overhead)
    - Network round trips
    - High CPU usage
    - Poor scalability
    - Long execution time

    Use BULK COLLECT and FORALL for bulk operations.
  base_severity: 10

  patterns:
    sql:
      - pattern: 'FOR\\s+\\w+\\s+IN\\s+\\([^)]*SELECT.*\\)\\s+LOOP.*UPDATE|FOR\\s+\\w+\\s+IN\\s+\\([^)]*SELECT.*\\)\\s+LOOP.*INSERT'
        context: 'PL/SQL cursor loop with DML (row-by-row)'
      - pattern: 'OPEN.*FETCH.*INTO.*LOOP'
        context: 'PL/SQL explicit cursor loop'

    java:
      - pattern: 'while\\s*\\(\\s*rs\\.next\\(\\)\\s*\\).*executeUpdate|while\\s*\\(\\s*rs\\.next\\(\\)\\s*\\).*execute'
        context: 'Java row-by-row processing with DML'

  fixes:
    description: |
      Use bulk operations for better performance:

      -- Bad - Row-by-row processing (VERY SLOW!)
      DECLARE
        CURSOR user_cursor IS SELECT user_id, bonus FROM users WHERE status = 'ACTIVE';
      BEGIN
        FOR user_rec IN user_cursor LOOP
          UPDATE accounts SET balance = balance + user_rec.bonus
          WHERE user_id = user_rec.user_id;
          -- Context switch for EACH row!
        END LOOP;
        COMMIT;
      END;
      -- 1000 rows = 1000 context switches!

      -- Good - BULK COLLECT + FORALL (10-100x faster)
      DECLARE
        TYPE user_id_array IS TABLE OF users.user_id%TYPE;
        TYPE bonus_array IS TABLE OF users.bonus%TYPE;
        v_user_ids user_id_array;
        v_bonuses bonus_array;
      BEGIN
        SELECT user_id, bonus
        BULK COLLECT INTO v_user_ids, v_bonuses
        FROM users WHERE status = 'ACTIVE';

        FORALL i IN 1..v_user_ids.COUNT
          UPDATE accounts SET balance = balance + v_bonuses(i)
          WHERE user_id = v_user_ids(i);

        COMMIT;
      END;
      -- 1000 rows = 1 context switch!

      -- Better - LIMIT clause for large datasets (avoid OOM)
      DECLARE
        CURSOR user_cursor IS SELECT user_id, bonus FROM users WHERE status = 'ACTIVE';
        TYPE user_table IS TABLE OF user_cursor%ROWTYPE;
        v_users user_table;
        c_limit CONSTANT PLS_INTEGER := 1000;  -- Process 1000 rows at a time
      BEGIN
        OPEN user_cursor;
        LOOP
          FETCH user_cursor BULK COLLECT INTO v_users LIMIT c_limit;
          EXIT WHEN v_users.COUNT = 0;

          FORALL i IN 1..v_users.COUNT
            UPDATE accounts SET balance = balance + v_users(i).bonus
            WHERE user_id = v_users(i).user_id;

          COMMIT;  -- Commit each batch
        END LOOP;
        CLOSE user_cursor;
      END;

      -- Best - Pure SQL (no PL/SQL needed)
      UPDATE accounts a
      SET balance = balance + (SELECT bonus FROM users u
                               WHERE u.user_id = a.user_id AND u.status = 'ACTIVE')
      WHERE EXISTS (SELECT 1 FROM users u
                    WHERE u.user_id = a.user_id AND u.status = 'ACTIVE');
      COMMIT;

    references:
      - 'Bulk processing: https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-optimization-and-tuning.html#GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA'
      - 'FORALL statement: https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/FORALL-statement.html'

---

rule:
  id: ORACLE_SELECT_FOR_UPDATE_WAIT
  category: database
  name: Oracle SELECT FOR UPDATE Without NOWAIT
  description: |
    SELECT FOR UPDATE without NOWAIT/SKIP LOCKED blocks indefinitely.
    Applications wait forever if row is locked by another session.

    Problems:
    - Indefinite blocking (waits forever)
    - Application hang
    - Timeout errors
    - Poor user experience
    - Deadlock risk

    Use NOWAIT or SKIP LOCKED for non-blocking lock attempts.
  base_severity: 9

  patterns:
    sql:
      - pattern: 'SELECT.*FOR\\s+UPDATE(?!.*NOWAIT|.*SKIP\\s+LOCKED)'
        context: 'SELECT FOR UPDATE without NOWAIT/SKIP LOCKED'

    java:
      - pattern: 'SELECT.*FOR\\s+UPDATE[\'"]'
        context: 'Java SQL with SELECT FOR UPDATE'

  fixes:
    description: |
      Use NOWAIT or SKIP LOCKED:

      -- Bad - Blocks indefinitely if row is locked
      SELECT * FROM orders WHERE order_id = 12345 FOR UPDATE;
      -- If another session has locked this row, your session WAITS FOREVER!
      -- Application appears hung to user

      -- Good - NOWAIT (immediate error if locked)
      BEGIN
        SELECT * FROM orders WHERE order_id = 12345 FOR UPDATE NOWAIT;
      EXCEPTION
        WHEN resource_busy THEN
          -- Handle locked row (retry, show message, etc.)
          DBMS_OUTPUT.PUT_LINE('Row is locked by another user');
      END;

      -- Better - SKIP LOCKED (skip locked rows)
      SELECT * FROM orders WHERE status = 'PENDING' FOR UPDATE SKIP LOCKED;
      -- Useful for work queue pattern (each worker gets unlocked rows)

      -- Best - WAIT timeout (wait up to N seconds)
      SELECT * FROM orders WHERE order_id = 12345 FOR UPDATE WAIT 5;
      -- Waits max 5 seconds, then raises resource_busy exception

      -- Java example - Bad
      String sql = "SELECT * FROM orders WHERE order_id = ? FOR UPDATE";
      PreparedStatement pstmt = conn.prepareStatement(sql);
      pstmt.setInt(1, orderId);
      ResultSet rs = pstmt.executeQuery();  // May hang forever!

      -- Java example - Good
      String sql = "SELECT * FROM orders WHERE order_id = ? FOR UPDATE NOWAIT";
      try {
        PreparedStatement pstmt = conn.prepareStatement(sql);
        pstmt.setInt(1, orderId);
        ResultSet rs = pstmt.executeQuery();
        // Process locked row
      } catch (SQLException e) {
        if (e.getErrorCode() == 54) {  // ORA-00054: resource busy
          // Handle locked row
          System.out.println("Row is locked, please retry");
        }
      }

      -- Work queue pattern with SKIP LOCKED
      DECLARE
        CURSOR job_cursor IS
          SELECT job_id, job_data FROM jobs
          WHERE status = 'PENDING'
          FOR UPDATE SKIP LOCKED;
      BEGIN
        FOR job_rec IN job_cursor LOOP
          -- Process job (guaranteed no other worker has this job)
          process_job(job_rec.job_id, job_rec.job_data);
          UPDATE jobs SET status = 'COMPLETED' WHERE job_id = job_rec.job_id;
          COMMIT;
        END LOOP;
      END;

    references:
      - 'Locking: https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6'
      - 'SKIP LOCKED: https://oracle-base.com/articles/11g/skip-locked-for-update-11gr1'

---

rule:
  id: ORACLE_MISSING_INDEX
  category: database
  name: Oracle Query Without Index
  description: |
    Queries without proper indexes cause full table scans.
    Oracle provides multiple index types for different use cases.

    Problems:
    - Full table scan (reads entire table)
    - High I/O and buffer cache usage
    - Query timeout on large tables
    - CPU overhead
    - Poor scalability

    Use appropriate index type: B-tree, Bitmap, Function-based, Text.
  base_severity: 9

  patterns:
    sql:
      - pattern: 'SELECT.*WHERE.*(?!.*INDEX|.*HINT)'
        context: 'SQL SELECT with WHERE (check index usage)'
      - pattern: 'CREATE\\s+TABLE.*(?!.*INDEX|.*PRIMARY\\s+KEY|.*CONSTRAINT)'
        context: 'Table without any indexes'

  fixes:
    description: |
      Create appropriate indexes:

      -- Bad - No index on frequently queried column
      CREATE TABLE users (
        user_id NUMBER PRIMARY KEY,
        email VARCHAR2(255),
        status VARCHAR2(50),
        created_date DATE
      );
      SELECT * FROM users WHERE email = 'user@example.com';  -- Full table scan!

      -- Good - B-tree index for high-cardinality columns
      CREATE INDEX idx_users_email ON users (email);
      SELECT * FROM users WHERE email = 'user@example.com';  -- Index range scan

      -- Better - Function-based index for case-insensitive search
      CREATE INDEX idx_users_email_upper ON users (UPPER(email));
      SELECT * FROM users WHERE UPPER(email) = 'USER@EXAMPLE.COM';  -- Uses index

      -- Best - Composite index for multiple columns
      CREATE INDEX idx_users_status_date ON users (status, created_date);
      SELECT * FROM users WHERE status = 'ACTIVE' AND created_date > SYSDATE - 30;

      -- Bitmap index for low-cardinality columns (data warehouse)
      CREATE BITMAP INDEX idx_users_status ON users (status);
      -- Good for: 'ACTIVE', 'INACTIVE', 'SUSPENDED' (few distinct values)
      -- Bad for: email, phone (many distinct values)

      -- Text index for full-text search
      CREATE INDEX idx_users_bio ON users (bio) INDEXTYPE IS CTXSYS.CONTEXT;
      SELECT * FROM users WHERE CONTAINS(bio, 'software engineer') > 0;

      -- Check missing indexes (Oracle 11g+)
      SELECT
        sql_id,
        sql_text,
        executions,
        elapsed_time / executions AS avg_elapsed_time,
        buffer_gets / executions AS avg_buffer_gets
      FROM v$sql
      WHERE executions > 100
        AND buffer_gets / executions > 10000  -- High buffer gets = likely missing index
      ORDER BY buffer_gets / executions DESC;

      -- Check execution plans
      EXPLAIN PLAN FOR
      SELECT * FROM users WHERE email = 'user@example.com';

      SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

      -- Check index usage
      SELECT
        owner,
        index_name,
        table_name,
        num_rows,
        distinct_keys,
        clustering_factor,
        status
      FROM dba_indexes
      WHERE table_name = 'USERS';

    references:
      - 'Index types: https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/indexes-and-index-organized-tables.html'
      - 'Query optimization: https://docs.oracle.com/en/database/oracle/oracle-database/21/tgsql/'

---

rule:
  id: ORACLE_COMMIT_IN_LOOP
  category: database
  name: Oracle COMMIT Inside Loop
  description: |
    COMMIT inside loop causes excessive overhead.
    Each COMMIT writes to redo logs and triggers checkpoint.

    Problems:
    - Redo log write overhead (each COMMIT)
    - Log file sync waits
    - Poor performance (10-100x slower)
    - Transaction management overhead
    - Rollback complexity

    COMMIT after loop completes, not inside loop.
  base_severity: 9

  patterns:
    sql:
      - pattern: 'LOOP.*COMMIT.*END\\s+LOOP|FOR.*LOOP.*COMMIT.*END\\s+LOOP'
        context: 'PL/SQL COMMIT inside loop'

  fixes:
    description: |
      COMMIT after loop, not inside:

      -- Bad - COMMIT inside loop (VERY SLOW!)
      DECLARE
        CURSOR user_cursor IS SELECT user_id FROM users WHERE status = 'PENDING';
      BEGIN
        FOR user_rec IN user_cursor LOOP
          UPDATE users SET status = 'PROCESSED' WHERE user_id = user_rec.user_id;
          COMMIT;  -- Redo log write for EACH row! (1000 rows = 1000 COMMITs)
        END LOOP;
      END;

      -- Good - Single COMMIT after loop (10-100x faster)
      DECLARE
        CURSOR user_cursor IS SELECT user_id FROM users WHERE status = 'PENDING';
      BEGIN
        FOR user_rec IN user_cursor LOOP
          UPDATE users SET status = 'PROCESSED' WHERE user_id = user_rec.user_id;
        END LOOP;
        COMMIT;  -- Single redo log write
      END;

      -- Better - Batch COMMIT for large datasets (avoid rollback segment overflow)
      DECLARE
        CURSOR user_cursor IS SELECT user_id FROM users WHERE status = 'PENDING';
        v_counter PLS_INTEGER := 0;
        c_batch_size CONSTANT PLS_INTEGER := 1000;
      BEGIN
        FOR user_rec IN user_cursor LOOP
          UPDATE users SET status = 'PROCESSED' WHERE user_id = user_rec.user_id;

          v_counter := v_counter + 1;
          IF v_counter >= c_batch_size THEN
            COMMIT;  -- COMMIT every 1000 rows
            v_counter := 0;
          END IF;
        END LOOP;

        COMMIT;  -- Final COMMIT for remaining rows
      END;

      -- Best - Bulk operation (no loop needed)
      UPDATE users SET status = 'PROCESSED' WHERE status = 'PENDING';
      COMMIT;

      -- Monitor redo log waits
      SELECT
        event,
        total_waits,
        total_timeouts,
        time_waited,
        average_wait
      FROM v$system_event
      WHERE event LIKE '%log file sync%'
      ORDER BY time_waited DESC;

    references:
      - 'Transaction management: https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/transactions.html'
      - 'COMMIT performance: https://oracle-base.com/articles/misc/commits-in-a-dml-loop'

---

rule:
  id: ORACLE_WRONG_OPTIMIZER_HINT
  category: database
  name: Oracle Optimizer Hint Misuse
  description: |
    Incorrect optimizer hints force bad execution plans.
    Hints override Oracle's cost-based optimizer.

    Problems:
    - Suboptimal execution plan
    - Full table scan instead of index
    - Poor join order
    - Performance degradation
    - Plan not adapting to data changes

    Let optimizer choose plan, or use hints carefully.
  base_severity: 8

  patterns:
    sql:
      - pattern: '/\\*\\+.*FULL\\s*\\(|/\\*\\+.*RULE\\s*\\*/'
        context: 'Oracle optimizer hint (FULL or RULE)'
      - pattern: '/\\*\\+.*USE_NL.*\\*/'
        context: 'Oracle nested loop hint'

  fixes:
    description: |
      Use hints carefully or let optimizer decide:

      -- Bad - FULL hint forces table scan (even if index exists)
      SELECT /*+ FULL(users) */ * FROM users WHERE user_id = 12345;
      -- Scans entire table instead of using primary key index!

      -- Good - Let optimizer choose (usually index range scan)
      SELECT * FROM users WHERE user_id = 12345;

      -- Bad - RULE hint uses outdated rule-based optimizer
      SELECT /*+ RULE */ * FROM users u, orders o
      WHERE u.user_id = o.user_id;
      -- Ignores statistics and modern cost-based optimization!

      -- Good - Cost-based optimizer (default)
      SELECT * FROM users u JOIN orders o ON u.user_id = o.user_id;

      -- When hints are appropriate - INDEX hint
      SELECT /*+ INDEX(users idx_users_email) */ *
      FROM users
      WHERE email LIKE 'admin%' AND status = 'ACTIVE';
      -- Forces specific index when optimizer chooses wrong one

      -- LEADING hint for join order
      SELECT /*+ LEADING(small_table large_table) */ *
      FROM small_table, large_table
      WHERE small_table.id = large_table.small_id;
      -- Join small table first (10 rows), then large table (1M rows)

      -- USE_HASH hint for large joins
      SELECT /*+ USE_HASH(orders customers) */ *
      FROM orders o JOIN customers c ON o.customer_id = c.customer_id;
      -- Hash join better than nested loop for large datasets

      -- PARALLEL hint for large queries
      SELECT /*+ PARALLEL(orders 4) */ COUNT(*)
      FROM orders
      WHERE order_date > SYSDATE - 365;
      -- Use 4 parallel processes

      -- Check actual execution plan
      SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL, NULL, 'ALLSTATS LAST'));

      -- Gather table statistics (important for optimizer)
      EXEC DBMS_STATS.GATHER_TABLE_STATS('MYSCHEMA', 'USERS', cascade => TRUE);

      -- Check if hint was used
      SELECT sql_id, sql_text, optimizer_mode, optimizer_cost
      FROM v$sql
      WHERE sql_text LIKE '%FULL%';

    references:
      - 'Optimizer hints: https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Comments.html#GUID-D316D545-89E2-4D54-977F-FC97815CD62E'
      - 'Query tuning: https://docs.oracle.com/en/database/oracle/oracle-database/21/tgsql/query-optimizer.html'

---

rule:
  id: ORACLE_BIND_VARIABLE_PEEKING
  category: database
  name: Oracle Bind Variable Peeking Issue
  description: |
    Bind variable peeking causes cached plans to be suboptimal for different values.
    Oracle creates plan based on first execution's bind values.

    Problems:
    - Wrong execution plan for different bind values
    - Table scan for selective query
    - Index scan for non-selective query
    - Unpredictable performance
    - Cardinality estimation errors

    Use adaptive cursor sharing or disable peeking for skewed data.
  base_severity: 8

  patterns:
    sql:
      - pattern: 'WHERE.*:\\w+|WHERE.*=\\s*:\\w+'
        context: 'SQL with bind variables (check skewness)'

    java:
      - pattern: 'setString\\(|setInt\\(|setLong\\('
        context: 'Java PreparedStatement with bind variables'

  fixes:
    description: |
      Handle bind variable peeking:

      -- Problem - Bind variable peeking
      -- First execution: :status = 'ACTIVE' (99% of rows)
      --   -> Optimizer creates plan with FULL TABLE SCAN (optimal for 99%)
      -- Second execution: :status = 'SUSPENDED' (0.1% of rows)
      --   -> Uses same FULL TABLE SCAN plan (BAD! Should use INDEX)

      PREPARE stmt FROM
      'SELECT * FROM users WHERE status = :status';

      -- Bad - No handling of bind peeking issue
      EXECUTE stmt USING 'ACTIVE';      -- Creates plan with full scan
      EXECUTE stmt USING 'SUSPENDED';   -- Uses same full scan plan (slow!)

      -- Good - Adaptive Cursor Sharing (Oracle 11g+, automatic)
      -- Oracle detects cardinality mismatch and creates child cursors
      ALTER SYSTEM SET "_optimizer_adaptive_cursor_sharing" = TRUE;

      -- Better - Disable bind peeking for skewed columns
      SELECT /*+ BIND_AWARE */ * FROM users WHERE status = :status;
      -- Forces multiple child cursors for different bind values

      -- Best - Histograms on skewed columns
      EXEC DBMS_STATS.GATHER_TABLE_STATS(
        ownname => 'MYSCHEMA',
        tabname => 'USERS',
        method_opt => 'FOR COLUMNS status SIZE AUTO',  -- Create histogram
        cascade => TRUE
      );

      -- Monitor bind-aware cursors
      SELECT
        sql_id,
        child_number,
        is_bind_aware,
        is_bind_sensitive,
        is_shareable
      FROM v$sql
      WHERE sql_text LIKE '%users%'
        AND is_bind_aware = 'Y';

      -- Check cursor sharing
      SELECT
        sql_id,
        COUNT(*) AS child_count,
        MAX(executions) AS max_executions
      FROM v$sql
      WHERE sql_text LIKE '%users%'
      GROUP BY sql_id
      HAVING COUNT(*) > 1  -- Multiple child cursors
      ORDER BY child_count DESC;

      -- Force hard parse (workaround)
      ALTER SYSTEM FLUSH SHARED_POOL;  -- Production: use with caution!

      -- Or use literals for extremely skewed queries
      SELECT * FROM users WHERE status = 'SUSPENDED';  -- Literal, not bind

    references:
      - 'Bind variable peeking: https://docs.oracle.com/en/database/oracle/oracle-database/21/tgsql/optimizer-access-paths.html#GUID-22EF1E8E-75C5-48B0-9759-8A5E8D9E9C3A'
      - 'Adaptive cursor sharing: https://oracle-base.com/articles/11g/adaptive-cursor-sharing-11gr1'

---

rule:
  id: ORACLE_MATERIALIZED_VIEW_REFRESH
  category: database
  name: Oracle Materialized View Refresh Issue
  description: |
    Materialized view refresh without FAST refresh causes full table recompute.
    COMPLETE refresh is extremely slow for large tables.

    Problems:
    - Full table scan and recompute (COMPLETE)
    - High I/O and CPU usage
    - Long refresh time (minutes/hours)
    - Locks during refresh
    - Stale data during refresh

    Use FAST refresh with materialized view logs.
  base_severity: 8

  patterns:
    sql:
      - pattern: 'CREATE\\s+MATERIALIZED\\s+VIEW.*REFRESH\\s+COMPLETE'
        context: 'Materialized view with COMPLETE refresh'
      - pattern: 'DBMS_MVIEW\\.REFRESH\\([^)]*method\\s*=>\\s*[\'"]C[\'"]'
        context: 'Manual refresh with COMPLETE method'

  fixes:
    description: |
      Use FAST refresh for incremental updates:

      -- Bad - COMPLETE refresh (full recompute)
      CREATE MATERIALIZED VIEW mv_user_orders
      REFRESH COMPLETE
      START WITH SYSDATE NEXT SYSDATE + 1/24  -- Every hour
      AS
      SELECT u.user_id, u.name, COUNT(o.order_id) AS order_count
      FROM users u JOIN orders o ON u.user_id = o.user_id
      GROUP BY u.user_id, u.name;
      -- COMPLETE refresh = full table scan + full recompute (SLOW!)

      -- Good - FAST refresh with materialized view logs
      -- Step 1: Create materialized view logs
      CREATE MATERIALIZED VIEW LOG ON users
      WITH ROWID, SEQUENCE (user_id, name)
      INCLUDING NEW VALUES;

      CREATE MATERIALIZED VIEW LOG ON orders
      WITH ROWID, SEQUENCE (order_id, user_id)
      INCLUDING NEW VALUES;

      -- Step 2: Create materialized view with FAST refresh
      CREATE MATERIALIZED VIEW mv_user_orders
      REFRESH FAST
      START WITH SYSDATE NEXT SYSDATE + 1/24
      AS
      SELECT u.user_id, u.name, COUNT(o.order_id) AS order_count
      FROM users u JOIN orders o ON u.user_id = o.user_id
      GROUP BY u.user_id, u.name;
      -- FAST refresh = only changed rows recomputed (10-1000x faster!)

      -- Better - ON COMMIT refresh for real-time updates
      CREATE MATERIALIZED VIEW mv_user_orders
      REFRESH FAST ON COMMIT
      AS
      SELECT u.user_id, u.name, COUNT(o.order_id) AS order_count
      FROM users u JOIN orders o ON u.user_id = o.user_id
      GROUP BY u.user_id, u.name;
      -- Auto-refresh on every COMMIT (milliseconds)

      -- Manual refresh
      EXEC DBMS_MVIEW.REFRESH('MV_USER_ORDERS', method => 'F');  -- FAST
      EXEC DBMS_MVIEW.REFRESH('MV_USER_ORDERS', method => 'C');  -- COMPLETE (slow)

      -- Check refresh capability
      SELECT
        mview_name,
        last_refresh_date,
        refresh_method,
        refresh_mode,
        fast_refreshable,
        stale_since
      FROM user_mviews;

      -- Check materialized view logs
      SELECT
        log_owner,
        master,
        log_table,
        rowids,
        sequence
      FROM user_mview_logs;

      -- Monitor refresh performance
      SELECT
        mview_name,
        refresh_id,
        refresh_method,
        start_time,
        end_time,
        elapsed_time,
        log_purge_time
      FROM user_mview_refresh_times
      ORDER BY start_time DESC;

    references:
      - 'Materialized views: https://docs.oracle.com/en/database/oracle/oracle-database/21/dwhsg/basic-materialized-views.html'
      - 'FAST refresh: https://docs.oracle.com/en/database/oracle/oracle-database/21/dwhsg/refreshing-materialized-views.html'

---

rule:
  id: ORACLE_IMPLICIT_DATATYPE_CONVERSION
  category: database
  name: Oracle Implicit Datatype Conversion
  description: |
    Implicit datatype conversions prevent index usage.
    Oracle converts data types when they don't match.

    Problems:
    - Index not used (full table scan)
    - Function on column prevents index
    - CPU overhead (conversion on every row)
    - Increased I/O
    - Query timeout

    Match data types exactly in WHERE clauses.
  base_severity: 9

  patterns:
    sql:
      - pattern: 'WHERE.*=\\s*[\'"]\\d+[\'"]'
        context: 'SQL comparing number column with string'
      - pattern: 'WHERE.*LIKE.*\\d+'
        context: 'LIKE on numeric column'

    java:
      - pattern: 'setString\\([^)]*\\d+\\)'
        context: 'Java setString with numeric value'

  fixes:
    description: |
      Avoid implicit conversions:

      -- Bad - Implicit conversion (NUMBER to VARCHAR2)
      SELECT * FROM users WHERE user_id = '12345';
      -- user_id is NUMBER, literal is VARCHAR2
      -- Oracle converts: WHERE TO_NUMBER('12345') = user_id
      -- Index on user_id NOT USED! (full table scan)

      -- Good - Correct data type (NUMBER)
      SELECT * FROM users WHERE user_id = 12345;
      -- Index range scan (fast!)

      -- Bad - Date to string conversion
      SELECT * FROM orders WHERE order_date = '2024-01-15';
      -- order_date is DATE, literal is VARCHAR2
      -- Oracle converts: WHERE order_date = TO_DATE('2024-01-15', 'YYYY-MM-DD')

      -- Good - DATE literal
      SELECT * FROM orders WHERE order_date = DATE '2024-01-15';
      -- Or use TO_DATE explicitly
      SELECT * FROM orders WHERE order_date = TO_DATE('2024-01-15', 'YYYY-MM-DD');

      -- Bad - Function on indexed column
      SELECT * FROM users WHERE UPPER(email) = 'USER@EXAMPLE.COM';
      -- UPPER() prevents index usage on email column

      -- Good - Function-based index
      CREATE INDEX idx_users_email_upper ON users (UPPER(email));
      SELECT * FROM users WHERE UPPER(email) = 'USER@EXAMPLE.COM';
      -- Index range scan with function-based index

      -- Bad - LIKE on numeric column
      SELECT * FROM orders WHERE order_id LIKE '123%';
      -- order_id is NUMBER, LIKE expects VARCHAR2
      -- Implicit: WHERE TO_CHAR(order_id) LIKE '123%'

      -- Good - Range query
      SELECT * FROM orders WHERE order_id BETWEEN 123000 AND 123999;

      -- Java - Bad (implicit conversion)
      PreparedStatement pstmt = conn.prepareStatement(
        "SELECT * FROM users WHERE user_id = ?"
      );
      pstmt.setString(1, "12345");  -- Wrong! user_id is NUMBER

      -- Java - Good (correct type)
      PreparedStatement pstmt = conn.prepareStatement(
        "SELECT * FROM users WHERE user_id = ?"
      );
      pstmt.setInt(1, 12345);  -- Correct type

      -- Check for implicit conversions in execution plans
      SELECT
        sql_id,
        sql_text,
        executions,
        buffer_gets / executions AS avg_buffer_gets
      FROM v$sql
      WHERE sql_text LIKE '%TO_NUMBER%' OR sql_text LIKE '%TO_CHAR%'
      ORDER BY buffer_gets / executions DESC;

      -- Check column data types
      SELECT
        column_name,
        data_type,
        data_length,
        data_precision,
        data_scale
      FROM user_tab_columns
      WHERE table_name = 'USERS';

    references:
      - 'Datatype conversion: https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Type-Comparison-Rules.html'
      - 'Implicit conversion: https://oracle-base.com/articles/misc/data-type-conversion'
