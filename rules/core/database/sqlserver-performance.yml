# SQL Server Performance Issues and Antipatterns
# Auto-generated by BugSearch2 - Database-Specific Rules
# Generated: 2025-10-14
# Category: database
# Target: Microsoft SQL Server

rule:
  id: SQLSERVER_MISSING_INDEX
  category: database
  name: SQL Server Query Without Index
  description: |
    Queries without proper indexes cause table scans.
    SQL Server provides missing index DMVs to identify needed indexes.

    Problems:
    - Table scan (reads entire table)
    - High I/O and CPU usage
    - Query timeout on large tables
    - Locks held longer
    - TempDB pressure (sorts/hashes spill to disk)

    Use sys.dm_db_missing_index_details to find missing indexes.
  base_severity: 9

  patterns:
    sql:
      - pattern: 'SELECT.*WHERE.*(?!.*WITH\s*\(INDEX)'
        context: 'SQL SELECT with WHERE clause (check index usage)'
      - pattern: 'CREATE\s+TABLE.*(?!.*INDEX|.*PRIMARY\s+KEY|.*CONSTRAINT)'
        context: 'Table without any indexes'

    csharp:
      - pattern: 'CommandText\s*=.*WHERE'
        context: 'C# SQL command with WHERE (check index usage)'

  fixes:
    description: |
      Create appropriate indexes based on query patterns:

      -- Bad - No index on frequently queried column
      CREATE TABLE Users (
        UserId INT PRIMARY KEY,
        Email NVARCHAR(255),
        CreatedDate DATETIME
      );
      SELECT * FROM Users WHERE Email = 'user@example.com';  -- Table Scan!

      -- Good - Nonclustered index on Email
      CREATE NONCLUSTERED INDEX IX_Users_Email ON Users (Email);
      SELECT * FROM Users WHERE Email = 'user@example.com';  -- Index Seek

      -- Better - Covering index (includes all selected columns)
      CREATE NONCLUSTERED INDEX IX_Users_Email_Covering
      ON Users (Email)
      INCLUDE (UserId, CreatedDate);  -- No key lookup needed

      -- Find missing indexes
      SELECT
        migs.avg_user_impact * (migs.user_seeks + migs.user_scans) AS Impact,
        mid.statement AS TableName,
        mid.equality_columns,
        mid.inequality_columns,
        mid.included_columns,
        'CREATE NONCLUSTERED INDEX IX_' +
          REPLACE(REPLACE(mid.statement, '[', ''), ']', '') +
          ' ON ' + mid.statement +
          ' (' + ISNULL(mid.equality_columns, '') +
          CASE WHEN mid.inequality_columns IS NOT NULL
            THEN ',' + mid.inequality_columns ELSE '' END + ')' +
          CASE WHEN mid.included_columns IS NOT NULL
            THEN ' INCLUDE (' + mid.included_columns + ')' ELSE '' END AS CreateIndexSQL
      FROM sys.dm_db_missing_index_details mid
      JOIN sys.dm_db_missing_index_groups mig ON mid.index_handle = mig.index_handle
      JOIN sys.dm_db_missing_index_group_stats migs ON mig.index_group_handle = migs.group_handle
      ORDER BY Impact DESC;

      -- Check existing index usage
      SELECT
        OBJECT_NAME(s.object_id) AS TableName,
        i.name AS IndexName,
        s.user_seeks,
        s.user_scans,
        s.user_lookups,
        s.user_updates
      FROM sys.dm_db_index_usage_stats s
      JOIN sys.indexes i ON s.object_id = i.object_id AND s.index_id = i.index_id
      WHERE OBJECTPROPERTY(s.object_id, 'IsUserTable') = 1
      ORDER BY s.user_seeks + s.user_scans + s.user_lookups DESC;

    references:
      - 'Missing indexes: https://docs.microsoft.com/en-us/sql/relational-databases/indexes/tune-nonclustered-missing-index-suggestions'
      - 'Index design: https://docs.microsoft.com/en-us/sql/relational-databases/sql-server-index-design-guide'

---

rule:
  id: SQLSERVER_INDEX_FRAGMENTATION
  category: database
  name: SQL Server Index Fragmentation
  description: |
    Fragmented indexes cause poor query performance.
    SQL Server requires regular index maintenance.

    Problems:
    - Extra I/O (reads scattered pages)
    - Slow range scans
    - Poor query performance
    - Inefficient page usage

    Rebuild (>30% fragmentation) or reorganize (5-30%) indexes regularly.
  base_severity: 8

  patterns:
    sql:
      - pattern: 'ALTER\s+INDEX.*REBUILD|ALTER\s+INDEX.*REORGANIZE'
        context: 'Index maintenance operation'

  fixes:
    description: |
      Monitor and fix index fragmentation:

      -- Check fragmentation
      SELECT
        OBJECT_NAME(ips.object_id) AS TableName,
        i.name AS IndexName,
        ips.index_type_desc,
        ips.avg_fragmentation_in_percent,
        ips.page_count,
        CASE
          WHEN ips.avg_fragmentation_in_percent > 30 THEN 'REBUILD'
          WHEN ips.avg_fragmentation_in_percent > 5 THEN 'REORGANIZE'
          ELSE 'OK'
        END AS Recommendation
      FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'LIMITED') ips
      JOIN sys.indexes i ON ips.object_id = i.object_id AND ips.index_id = i.index_id
      WHERE ips.page_count > 100  -- Skip small indexes
      ORDER BY ips.avg_fragmentation_in_percent DESC;

      -- Bad - Never maintain indexes (fragmentation accumulates)

      -- Good - Reorganize moderately fragmented indexes (5-30%)
      ALTER INDEX IX_Users_Email ON Users REORGANIZE;

      -- Better - Rebuild heavily fragmented indexes (>30%)
      ALTER INDEX IX_Users_Email ON Users REBUILD WITH (ONLINE = ON, SORT_IN_TEMPDB = ON);

      -- Best - Automated maintenance script
      DECLARE @TableName NVARCHAR(255);
      DECLARE @IndexName NVARCHAR(255);
      DECLARE @Fragmentation FLOAT;

      DECLARE IndexCursor CURSOR FOR
      SELECT
        OBJECT_NAME(ips.object_id),
        i.name,
        ips.avg_fragmentation_in_percent
      FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'LIMITED') ips
      JOIN sys.indexes i ON ips.object_id = i.object_id AND ips.index_id = i.index_id
      WHERE ips.avg_fragmentation_in_percent > 5 AND ips.page_count > 100;

      OPEN IndexCursor;
      FETCH NEXT FROM IndexCursor INTO @TableName, @IndexName, @Fragmentation;

      WHILE @@FETCH_STATUS = 0
      BEGIN
        IF @Fragmentation > 30
          EXEC('ALTER INDEX ' + @IndexName + ' ON ' + @TableName + ' REBUILD WITH (ONLINE = ON)');
        ELSE
          EXEC('ALTER INDEX ' + @IndexName + ' ON ' + @TableName + ' REORGANIZE');

        FETCH NEXT FROM IndexCursor INTO @TableName, @IndexName, @Fragmentation;
      END;

      CLOSE IndexCursor;
      DEALLOCATE IndexCursor;

      -- Schedule with SQL Server Agent
      -- Run weekly during maintenance window

    references:
      - 'Index fragmentation: https://docs.microsoft.com/en-us/sql/relational-databases/indexes/reorganize-and-rebuild-indexes'
      - 'Maintenance plans: https://docs.microsoft.com/en-us/sql/relational-databases/maintenance-plans/maintenance-plans'

---

rule:
  id: SQLSERVER_DEADLOCK
  category: database
  name: SQL Server Deadlock Risk
  description: |
    Queries accessing tables in different orders cause deadlocks.
    SQL Server automatically chooses deadlock victim and rolls back transaction.

    Problems:
    - Transaction rollback (1205 error)
    - Application errors
    - Performance degradation
    - User experience issues

    Access tables in consistent order and keep transactions short.
  base_severity: 9

  patterns:
    csharp:
      - pattern: 'BEGIN\s+TRANSACTION.*UPDATE.*UPDATE|BeginTransaction\(\).*ExecuteNonQuery.*ExecuteNonQuery'
        context: 'C# multiple updates in transaction (deadlock risk)'

    sql:
      - pattern: 'BEGIN\s+TRANSACTION.*UPDATE.*UPDATE'
        context: 'SQL multiple updates in transaction'

  fixes:
    description: |
      Prevent deadlocks:

      -- Bad - Tables accessed in different order (deadlock prone)
      -- Transaction 1:
      BEGIN TRANSACTION;
      UPDATE Orders SET Status = 'Shipped' WHERE OrderId = 1;
      UPDATE Customers SET LastOrderDate = GETDATE() WHERE CustomerId = 100;
      COMMIT;

      -- Transaction 2 (runs concurrently):
      BEGIN TRANSACTION;
      UPDATE Customers SET Balance = Balance - 100 WHERE CustomerId = 100;  -- Lock Customers
      UPDATE Orders SET PaymentStatus = 'Paid' WHERE OrderId = 1;           -- Lock Orders
      COMMIT;
      -- DEADLOCK! (Order of table access conflicts)

      -- Good - Consistent table access order
      -- Both transactions access in same order: Customers -> Orders
      BEGIN TRANSACTION;
      UPDATE Customers SET Balance = Balance - 100 WHERE CustomerId = 100;
      UPDATE Orders SET PaymentStatus = 'Paid' WHERE OrderId = 1;
      COMMIT;

      -- Better - Shorter transactions (release locks quickly)
      BEGIN TRANSACTION;
      UPDATE Orders SET Status = 'Shipped' WHERE OrderId = 1;
      COMMIT;

      BEGIN TRANSACTION;
      UPDATE Customers SET LastOrderDate = GETDATE() WHERE CustomerId = 100;
      COMMIT;

      -- Best - Use WITH (ROWLOCK, UPDLOCK) to minimize lock escalation
      BEGIN TRANSACTION;
      SELECT * FROM Orders WITH (ROWLOCK, UPDLOCK) WHERE OrderId = 1;
      UPDATE Orders SET Status = 'Shipped' WHERE OrderId = 1;
      COMMIT;

      -- Monitor deadlocks
      SELECT
        deadlock_count = COUNT(*),
        last_deadlock = MAX(creation_time)
      FROM sys.dm_exec_query_stats
      WHERE deadlock_count > 0;

      -- Trace deadlocks (use Extended Events)
      CREATE EVENT SESSION DeadlockMonitor ON SERVER
      ADD EVENT sqlserver.xml_deadlock_report
      ADD TARGET package0.event_file(SET filename=N'C:\Deadlocks.xel');

      ALTER EVENT SESSION DeadlockMonitor ON SERVER STATE = START;

    references:
      - 'Deadlock troubleshooting: https://docs.microsoft.com/en-us/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide'
      - 'Extended Events: https://docs.microsoft.com/en-us/sql/relational-databases/extended-events/extended-events'

---

rule:
  id: SQLSERVER_TEMPDB_CONTENTION
  category: database
  name: SQL Server TempDB Contention
  description: |
    TempDB contention causes performance degradation.
    Common with sorting, hashing, temporary tables, and cursors.

    Problems:
    - PAGELATCH_UP waits
    - Query slowdown
    - High CPU usage
    - Allocation bottleneck

    Configure multiple TempDB files (1 per CPU core, max 8).
  base_severity: 8

  patterns:
    sql:
      - pattern: 'SELECT.*ORDER\s+BY.*(?!.*INDEX)|SELECT.*GROUP\s+BY.*(?!.*INDEX)'
        context: 'SQL sort/hash operation (may spill to TempDB)'
      - pattern: 'CREATE\s+TABLE\s+#|DECLARE.*TABLE|SELECT.*INTO\s+#'
        context: 'Temporary table creation'

    csharp:
      - pattern: 'CREATE\s+TABLE\s+#|#\\w+'
        context: 'C# creating temp table'

  fixes:
    description: |
      Optimize TempDB configuration:

      -- Bad - Single TempDB file (default on old SQL Server)
      -- Causes allocation contention with many concurrent queries

      -- Good - Multiple TempDB files (1 per CPU core, max 8)
      -- Run on SQL Server startup:
      USE master;
      GO

      -- Add TempDB files (example for 4 CPU cores)
      ALTER DATABASE tempdb
      ADD FILE (
        NAME = tempdev2,
        FILENAME = 'C:\TempDB\tempdev2.ndf',
        SIZE = 8GB,
        FILEGROWTH = 512MB
      );

      ALTER DATABASE tempdb
      ADD FILE (
        NAME = tempdev3,
        FILENAME = 'C:\TempDB\tempdev3.ndf',
        SIZE = 8GB,
        FILEGROWTH = 512MB
      );

      -- Set equal file sizes (important!)
      ALTER DATABASE tempdb
      MODIFY FILE (NAME = tempdev, SIZE = 8GB, FILEGROWTH = 512MB);

      -- Better - Avoid TempDB usage with query optimization
      -- Bad - Sort spills to TempDB
      SELECT * FROM Users ORDER BY CreatedDate DESC;  -- No index!

      -- Good - Use index to avoid sort
      CREATE INDEX IX_Users_CreatedDate ON Users (CreatedDate DESC);
      SELECT * FROM Users ORDER BY CreatedDate DESC;  -- No TempDB needed

      -- Avoid unnecessary temp tables
      -- Bad - Temp table
      SELECT * INTO #TempUsers FROM Users WHERE Status = 'Active';
      SELECT * FROM #TempUsers WHERE CreatedDate > '2024-01-01';

      -- Good - Single query with CTE
      WITH ActiveUsers AS (
        SELECT * FROM Users WHERE Status = 'Active'
      )
      SELECT * FROM ActiveUsers WHERE CreatedDate > '2024-01-01';

      -- Monitor TempDB contention
      SELECT
        wait_type,
        waiting_tasks_count,
        wait_time_ms,
        signal_wait_time_ms
      FROM sys.dm_os_wait_stats
      WHERE wait_type LIKE 'PAGELATCH%'
      ORDER BY wait_time_ms DESC;

      -- Check TempDB usage
      SELECT
        SUM(unallocated_extent_page_count) AS FreePages,
        SUM(user_object_reserved_page_count) AS UserObjectPages,
        SUM(internal_object_reserved_page_count) AS InternalObjectPages
      FROM sys.dm_db_file_space_usage;

    references:
      - 'TempDB optimization: https://docs.microsoft.com/en-us/sql/relational-databases/databases/tempdb-database'
      - 'Contention troubleshooting: https://docs.microsoft.com/en-us/troubleshoot/sql/performance/resolve-pagelatch-ex-contention'

---

rule:
  id: SQLSERVER_PARAMETER_SNIFFING
  category: database
  name: SQL Server Parameter Sniffing Issue
  description: |
    Parameter sniffing causes cached query plans to be suboptimal for different parameters.
    SQL Server creates plan based on first execution's parameters.

    Problems:
    - Wrong query plan for different parameters
    - Table scan instead of index seek
    - Performance varies by parameter value
    - Unpredictable query performance

    Use OPTION (RECOMPILE) or OPTIMIZE FOR for parameter-sensitive queries.
  base_severity: 8

  patterns:
    csharp:
      - pattern: 'Parameters\\.Add.*CommandType\\.StoredProcedure'
        context: 'C# stored procedure call (check parameter sniffing)'

    sql:
      - pattern: 'CREATE\s+PROCEDURE.*@\\w+.*SELECT.*WHERE.*@\\w+'
        context: 'Stored procedure with parameters'

  fixes:
    description: |
      Handle parameter sniffing:

      -- Bad - Parameter sniffing problem
      CREATE PROCEDURE GetUsersByStatus
        @Status NVARCHAR(50)
      AS
      BEGIN
        SELECT * FROM Users WHERE Status = @Status;
        -- If first execution: @Status = 'Active' (99% of users)
        --   -> Query plan: Table Scan (optimal for 99%)
        -- If later execution: @Status = 'Suspended' (0.1% of users)
        --   -> Uses same Table Scan plan (BAD! Should use Index Seek)
      END;

      -- Good - OPTION (RECOMPILE) for parameter-sensitive queries
      CREATE PROCEDURE GetUsersByStatus
        @Status NVARCHAR(50)
      AS
      BEGIN
        SELECT * FROM Users
        WHERE Status = @Status
        OPTION (RECOMPILE);  -- Generate new plan each execution
      END;

      -- Better - OPTIMIZE FOR for known parameter distribution
      CREATE PROCEDURE GetUsersByStatus
        @Status NVARCHAR(50)
      AS
      BEGIN
        SELECT * FROM Users
        WHERE Status = @Status
        OPTION (OPTIMIZE FOR (@Status = 'Active'));  -- Optimize for common value
      END;

      -- Best - Local variable to avoid sniffing (older workaround)
      CREATE PROCEDURE GetUsersByStatus
        @Status NVARCHAR(50)
      AS
      BEGIN
        DECLARE @LocalStatus NVARCHAR(50) = @Status;
        SELECT * FROM Users
        WHERE Status = @LocalStatus;  -- Uses average statistics
      END;

      -- For ad-hoc queries - Use OPTIMIZE FOR UNKNOWN
      SELECT * FROM Users
      WHERE Status = @Status
      OPTION (OPTIMIZE FOR (@Status UNKNOWN));

      -- Monitor parameter sniffing issues
      SELECT
        qs.execution_count,
        qs.total_elapsed_time / qs.execution_count AS avg_elapsed_time,
        qs.min_elapsed_time,
        qs.max_elapsed_time,
        SUBSTRING(qt.text, (qs.statement_start_offset/2)+1,
          ((CASE qs.statement_end_offset
            WHEN -1 THEN DATALENGTH(qt.text)
            ELSE qs.statement_end_offset
          END - qs.statement_start_offset)/2) + 1) AS query_text
      FROM sys.dm_exec_query_stats qs
      CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt
      WHERE qs.max_elapsed_time > qs.min_elapsed_time * 10  -- 10x variance
      ORDER BY qs.max_elapsed_time - qs.min_elapsed_time DESC;

    references:
      - 'Parameter sniffing: https://docs.microsoft.com/en-us/sql/relational-databases/query-processing-architecture-guide#parameter-sensitivity'
      - 'Query hints: https://docs.microsoft.com/en-us/sql/t-sql/queries/hints-transact-sql-query'

---

rule:
  id: SQLSERVER_STATISTICS_OUTDATED
  category: database
  name: SQL Server Outdated Statistics
  description: |
    Outdated statistics cause suboptimal query plans.
    SQL Server uses statistics to estimate row counts and choose execution plans.

    Problems:
    - Wrong cardinality estimates
    - Suboptimal join order
    - Table scan instead of index seek
    - Poor query performance

    Update statistics regularly or enable auto-update.
  base_severity: 8

  patterns:
    sql:
      - pattern: 'UPDATE\s+STATISTICS|DBCC\s+SHOW_STATISTICS'
        context: 'Statistics maintenance'

  fixes:
    description: |
      Maintain up-to-date statistics:

      -- Check outdated statistics
      SELECT
        OBJECT_NAME(s.object_id) AS TableName,
        s.name AS StatisticsName,
        sp.last_updated,
        sp.rows,
        sp.rows_sampled,
        sp.modification_counter,
        CASE
          WHEN sp.modification_counter > sp.rows * 0.2 THEN 'Update needed'
          ELSE 'OK'
        END AS Status
      FROM sys.stats s
      CROSS APPLY sys.dm_db_stats_properties(s.object_id, s.stats_id) sp
      WHERE OBJECTPROPERTY(s.object_id, 'IsUserTable') = 1
      ORDER BY sp.modification_counter DESC;

      -- Bad - Statistics never updated (plans degrade over time)

      -- Good - Manual statistics update
      UPDATE STATISTICS Users;

      -- Better - Update with full scan (more accurate)
      UPDATE STATISTICS Users WITH FULLSCAN;

      -- Best - Enable auto-update statistics (default, but verify)
      ALTER DATABASE MyDatabase SET AUTO_UPDATE_STATISTICS ON;
      ALTER DATABASE MyDatabase SET AUTO_UPDATE_STATISTICS_ASYNC ON;  -- Async update

      -- Update specific statistics
      UPDATE STATISTICS Users IX_Users_Email WITH FULLSCAN;

      -- Create statistics on filtered columns
      CREATE STATISTICS Stats_ActiveUsers ON Users (Status)
      WHERE Status = 'Active';

      -- Monitor statistics usage
      SELECT
        OBJECT_NAME(s.object_id) AS TableName,
        s.name AS StatName,
        s.auto_created,
        s.user_created,
        s.no_recompute,
        sp.last_updated,
        sp.modification_counter
      FROM sys.stats s
      CROSS APPLY sys.dm_db_stats_properties(s.object_id, s.stats_id) sp
      WHERE OBJECTPROPERTY(s.object_id, 'IsUserTable') = 1
        AND sp.modification_counter > 1000
      ORDER BY sp.modification_counter DESC;

      -- Scheduled maintenance job
      -- Create SQL Server Agent job to run weekly:
      EXEC sp_updatestats;  -- Update all statistics

    references:
      - 'Statistics: https://docs.microsoft.com/en-us/sql/relational-databases/statistics/statistics'
      - 'Cardinality estimation: https://docs.microsoft.com/en-us/sql/relational-databases/performance/cardinality-estimation-sql-server'

---

rule:
  id: SQLSERVER_IMPLICIT_CONVERSION
  category: database
  name: SQL Server Implicit Type Conversion
  description: |
    Implicit type conversions prevent index usage and cause performance issues.
    SQL Server converts data types when they don't match.

    Problems:
    - Index scan instead of seek
    - CPU overhead (conversion on every row)
    - Increased I/O
    - Query timeout

    Match parameter types with column types exactly.
  base_severity: 9

  patterns:
    csharp:
      - pattern: 'Parameters\\.Add\\([^)]*DbType\\.String[^)]*\\)'
        context: 'C# parameter type (verify matches column type)'

    sql:
      - pattern: "WHERE.*=\\\\s*[\"'][0-9]+[\"']"
        context: 'SQL comparing number column with string'

  fixes:
    description: |
      Avoid implicit conversions:

      -- Bad - Implicit conversion (INT to NVARCHAR)
      DECLARE @UserId NVARCHAR(50) = '123';
      SELECT * FROM Users WHERE UserId = @UserId;
      -- UserId column is INT, parameter is NVARCHAR
      -- Index on UserId cannot be used! (scan instead of seek)

      -- Good - Explicit correct type
      DECLARE @UserId INT = 123;
      SELECT * FROM Users WHERE UserId = @UserId;
      -- Index seek (fast!)

      -- Bad - String comparison on numeric column
      SELECT * FROM Orders WHERE OrderId = '12345';  -- OrderId is INT

      -- Good - Numeric comparison
      SELECT * FROM Orders WHERE OrderId = 12345;

      -- C# - Bad (implicit conversion)
      SqlCommand cmd = new SqlCommand("SELECT * FROM Users WHERE UserId = @UserId", conn);
      cmd.Parameters.Add("@UserId", SqlDbType.NVarChar).Value = "123";  -- Wrong type!

      -- C# - Good (correct type)
      SqlCommand cmd = new SqlCommand("SELECT * FROM Users WHERE UserId = @UserId", conn);
      cmd.Parameters.Add("@UserId", SqlDbType.Int).Value = 123;  -- Correct type

      -- Find implicit conversions in execution plans
      SELECT
        qs.execution_count,
        qs.total_worker_time / qs.execution_count AS avg_cpu_time,
        SUBSTRING(qt.text, (qs.statement_start_offset/2)+1,
          ((CASE qs.statement_end_offset
            WHEN -1 THEN DATALENGTH(qt.text)
            ELSE qs.statement_end_offset
          END - qs.statement_start_offset)/2) + 1) AS query_text,
        qp.query_plan
      FROM sys.dm_exec_query_stats qs
      CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt
      CROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) qp
      WHERE CAST(qp.query_plan AS NVARCHAR(MAX)) LIKE '%CONVERT_IMPLICIT%'
      ORDER BY qs.total_worker_time DESC;

      -- Check column data types
      SELECT
        TABLE_NAME,
        COLUMN_NAME,
        DATA_TYPE,
        CHARACTER_MAXIMUM_LENGTH
      FROM INFORMATION_SCHEMA.COLUMNS
      WHERE TABLE_NAME = 'Users';

    references:
      - 'Data type conversions: https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-type-conversion-database-engine'
      - 'Implicit conversions: https://www.sqlskills.com/blogs/jonathan/implicit-conversions-that-cause-index-scans/'

---

rule:
  id: SQLSERVER_CURSOR_ABUSE
  category: database
  name: SQL Server Cursor Performance Issue
  description: |
    Cursors are slow and should be avoided in SQL Server.
    Set-based operations are 10-100x faster.

    Problems:
    - Row-by-row processing (slow)
    - High memory usage
    - TempDB pressure
    - Locks held longer
    - CPU overhead

    Use set-based operations (JOIN, UPDATE, DELETE) instead.
  base_severity: 8

  patterns:
    sql:
      - pattern: 'DECLARE.*CURSOR\\s+FOR|OPEN\\s+\\w+Cursor|FETCH\\s+NEXT'
        context: 'SQL cursor usage'

    csharp:
      - pattern: 'SqlDataReader.*Read\(\).*while'
        context: 'C# row-by-row processing (consider set-based)'

  fixes:
    description: |
      Replace cursors with set-based operations:

      -- Bad - Cursor (row-by-row processing)
      DECLARE @UserId INT, @Total DECIMAL(18,2);
      DECLARE UserCursor CURSOR FOR
        SELECT UserId FROM Users WHERE Status = 'Active';

      OPEN UserCursor;
      FETCH NEXT FROM UserCursor INTO @UserId;

      WHILE @@FETCH_STATUS = 0
      BEGIN
        SELECT @Total = SUM(Amount) FROM Orders WHERE UserId = @UserId;
        UPDATE Users SET TotalSpent = @Total WHERE UserId = @UserId;
        FETCH NEXT FROM UserCursor INTO @UserId;
      END;

      CLOSE UserCursor;
      DEALLOCATE UserCursor;
      -- Slow! (N queries + N updates)

      -- Good - Set-based operation (single UPDATE with JOIN)
      UPDATE u
      SET u.TotalSpent = t.Total
      FROM Users u
      JOIN (
        SELECT UserId, SUM(Amount) AS Total
        FROM Orders
        GROUP BY UserId
      ) t ON u.UserId = t.UserId
      WHERE u.Status = 'Active';
      -- Fast! (single query + single update)

      -- Bad - Cursor for aggregation
      DECLARE @Sum DECIMAL(18,2) = 0;
      DECLARE OrderCursor CURSOR FOR SELECT Amount FROM Orders;
      OPEN OrderCursor;
      FETCH NEXT FROM OrderCursor INTO @Amount;
      WHILE @@FETCH_STATUS = 0
      BEGIN
        SET @Sum = @Sum + @Amount;
        FETCH NEXT FROM OrderCursor INTO @Amount;
      END;
      CLOSE OrderCursor;
      DEALLOCATE OrderCursor;

      -- Good - Use built-in aggregate
      SELECT @Sum = SUM(Amount) FROM Orders;

      -- When cursor is truly needed (rare), use FAST_FORWARD
      DECLARE UserCursor CURSOR FAST_FORWARD FOR
        SELECT UserId, Email FROM Users;
      -- FAST_FORWARD = read-only, forward-only (faster than default)

      -- Monitor cursor usage
      SELECT
        creation_time,
        cursor_id,
        name,
        properties,
        sql_handle
      FROM sys.dm_exec_cursors(0);

    references:
      - 'Cursors vs set-based: https://www.sqlshack.com/curse-of-cursors-in-sql-server/'
      - 'T-SQL best practices: https://docs.microsoft.com/en-us/sql/t-sql/queries/select-transact-sql'
