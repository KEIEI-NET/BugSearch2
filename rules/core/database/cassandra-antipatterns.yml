# Cassandra Database Antipatterns and Performance Issues
# Auto-generated by BugSearch2 - Database-Specific Rules
# Generated: 2025-10-14
# Category: database
# Target: Apache Cassandra NoSQL Database

rule:
  id: CASSANDRA_SELECT_STAR
  category: database
  name: Cassandra SELECT * Usage
  description: |
    SELECT * in Cassandra is highly inefficient and dangerous.
    Unlike relational databases, Cassandra stores data in a column-family model.
    SELECT * forces deserialization of all columns, causing massive memory overhead.

    Problems:
    - Reads unnecessary tombstones
    - Causes OOM errors in large tables
    - Increases network bandwidth usage
    - Slows down query performance significantly

    Always specify exact columns needed.
  base_severity: 9

  patterns:
    java:
      - pattern: 'select\s+\*\s+from\s+[a-zA-Z_][a-zA-Z0-9_]*'
        context: 'CQL SELECT * query'
      - pattern: 'SELECT\s+\*\s+FROM\s+[a-zA-Z_][a-zA-Z0-9_]*'
        context: 'CQL SELECT * query (uppercase)'
      - pattern: "session\\.execute\\([\"']select\\s+\\*\\s+from"
        context: 'Cassandra session execute with SELECT *'

    python:
      - pattern: "execute\\([\"']select\\s+\\*\\s+from"
        context: 'Python Cassandra driver SELECT *'
      - pattern: "session\\.execute\\([\"']SELECT\\s+\\*\\s+FROM"
        context: 'Python Cassandra driver SELECT * (uppercase)'

    javascript:
      - pattern: "client\\.execute\\([\"']select\\s+\\*\\s+from"
        context: 'Node.js Cassandra driver SELECT *'

    csharp:
      - pattern: "session\\.Execute\\([\"']select\\s+\\*\\s+from"
        context: 'C# Cassandra driver SELECT *'
      - pattern: "QueryAsync\\([\"']SELECT\\s+\\*\\s+FROM"
        context: 'C# Cassandra async query SELECT *'

    go:
      - pattern: "session\\.Query\\([\"']select\\s+\\*\\s+from"
        context: 'Go Cassandra driver SELECT *'

  fixes:
    description: |
      Specify exact columns you need:

      // Bad
      SELECT * FROM users WHERE user_id = ?

      // Good
      SELECT user_id, username, email, created_at FROM users WHERE user_id = ?

      Benefits:
      - Reduces memory usage by 90%+
      - Avoids tombstone reads
      - Improves query latency
      - Prevents OOM errors

    references:
      - 'Cassandra Best Practices: https://cassandra.apache.org/doc/latest/data_modeling/'
      - 'DataStax Performance Tuning: https://docs.datastax.com/en/dse/6.8/cql/cql/cql_using/useQueryPerformance.html'

---

rule:
  id: CASSANDRA_ALLOW_FILTERING
  category: database
  name: Cassandra ALLOW FILTERING Usage
  description: |
    ALLOW FILTERING forces Cassandra to scan entire partition or table.
    This bypasses the distributed architecture and causes severe performance degradation.

    Problems:
    - Scans ALL nodes in the cluster
    - Reads ALL partitions (full table scan)
    - Causes coordinator node OOM
    - Query timeout on large datasets
    - Increases latency from ms to minutes

    ALLOW FILTERING should NEVER be used in production.
    It's only acceptable for small test tables (<1000 rows).
  base_severity: 10

  patterns:
    java:
      - pattern: 'ALLOW\s+FILTERING'
        context: 'CQL ALLOW FILTERING clause'
      - pattern: 'allow\s+filtering'
        context: 'CQL allow filtering clause (lowercase)'
      - pattern: 'session\.execute\(.*ALLOW\s+FILTERING'
        context: 'Cassandra session execute with ALLOW FILTERING'

    python:
      - pattern: "execute\\(.*[\"'].*ALLOW\\s+FILTERING"
        context: 'Python Cassandra driver ALLOW FILTERING'

    javascript:
      - pattern: 'client\.execute\(.*ALLOW\s+FILTERING'
        context: 'Node.js Cassandra driver ALLOW FILTERING'

    csharp:
      - pattern: 'Execute\(.*ALLOW\s+FILTERING'
        context: 'C# Cassandra driver ALLOW FILTERING'

    go:
      - pattern: 'Query\(.*ALLOW\s+FILTERING'
        context: 'Go Cassandra driver ALLOW FILTERING'

  fixes:
    description: |
      Fix by redesigning your data model with proper partition keys:

      // Bad - Full table scan
      SELECT * FROM users WHERE age > 25 ALLOW FILTERING

      // Good - Create materialized view or secondary index
      CREATE MATERIALIZED VIEW users_by_age AS
        SELECT * FROM users
        WHERE age IS NOT NULL AND user_id IS NOT NULL
        PRIMARY KEY (age, user_id)

      SELECT * FROM users_by_age WHERE age > 25

      Or use secondary index for low-cardinality columns:
      CREATE INDEX ON users (age)
      SELECT * FROM users WHERE age = 25  -- No ALLOW FILTERING needed

    references:
      - 'Why ALLOW FILTERING is bad: https://www.datastax.com/blog/allow-filtering-explained'
      - 'Data modeling best practices: https://cassandra.apache.org/doc/latest/data_modeling/'

---

rule:
  id: CASSANDRA_IN_CLAUSE_ABUSE
  category: database
  name: Cassandra Excessive IN Clause Usage
  description: |
    IN clause with many values forces Cassandra to query multiple partitions.
    This defeats the distributed architecture and causes performance issues.

    Problems:
    - Queries multiple coordinators
    - Increases latency linearly with IN values
    - Can cause timeout with >100 values
    - Uneven load distribution

    Limit IN clause to <10 values, or redesign data model.
  base_severity: 8

  patterns:
    java:
      - pattern: 'IN\s*\([^)]{100,}\)'
        context: 'CQL IN clause with many values (>100 chars)'
      - pattern: 'where\s+[a-zA-Z_]+\s+in\s*\('
        context: 'CQL WHERE with IN clause'

    python:
      - pattern: 'IN\s*\(\s*[\'"]\s*,\s*[\'"]\s*,.*\)'
        context: 'Python CQL IN clause with multiple values'

    javascript:
      - pattern: 'IN\s*\([^)]{100,}\)'
        context: 'JavaScript CQL IN clause'

    csharp:
      - pattern: 'IN\s*\([^)]{100,}\)'
        context: 'C# CQL IN clause'

  fixes:
    description: |
      Limit IN clause or redesign:

      // Bad - Too many values
      SELECT * FROM users WHERE user_id IN (1,2,3,...,1000)

      // Good - Use async batch queries
      for batch in batches(user_ids, batch_size=10):
          results = await session.execute(
              "SELECT * FROM users WHERE user_id IN ?", [batch]
          )

      // Better - Redesign with partition key
      SELECT * FROM users_by_group WHERE group_id = ?

    references:
      - 'IN clause performance: https://www.datastax.com/blog/most-important-thing-know-about-cassandra-data-modeling'

---

rule:
  id: CASSANDRA_SECONDARY_INDEX_ABUSE
  category: database
  name: Cassandra Secondary Index on High-Cardinality Column
  description: |
    Secondary indexes on high-cardinality columns (e.g. timestamp, UUID)
    cause severe performance issues in Cassandra.

    Problems:
    - Index spans ALL nodes
    - Query scans entire cluster
    - Memory overhead for index
    - Slow writes (index update overhead)

    Use secondary indexes ONLY for low-cardinality columns.
    For high-cardinality, use materialized views or redesign partition key.
  base_severity: 9

  patterns:
    java:
      - pattern: 'CREATE\s+INDEX.*ON.*\((timestamp|created_at|updated_at|id|uuid)'
        context: 'CQL secondary index on timestamp/UUID'
      - pattern: 'CREATE\s+INDEX.*email|phone|address'
        context: 'CQL secondary index on high-cardinality column'

    python:
      - pattern: 'CREATE\s+INDEX.*ON.*\((timestamp|created_at|updated_at|id|uuid)'
        context: 'Python CQL secondary index on high-cardinality'

  fixes:
    description: |
      Use materialized views for high-cardinality columns:

      // Bad - Secondary index on timestamp
      CREATE INDEX ON events (timestamp)

      // Good - Materialized view
      CREATE MATERIALIZED VIEW events_by_timestamp AS
        SELECT * FROM events
        WHERE timestamp IS NOT NULL AND event_id IS NOT NULL
        PRIMARY KEY (timestamp, event_id)

      Or redesign partition key:
      CREATE TABLE events_by_day (
        day date,
        timestamp timestamp,
        event_id uuid,
        data text,
        PRIMARY KEY ((day), timestamp, event_id)
      )

    references:
      - 'When to use secondary indexes: https://docs.datastax.com/en/cql-oss/3.3/cql/cql_using/useSecondaryIndex.html'

---

rule:
  id: CASSANDRA_BATCH_LOGGED_ABUSE
  category: database
  name: Cassandra Logged Batch Misuse
  description: |
    LOGGED BATCH in Cassandra is NOT for performance optimization.
    It's ONLY for atomic writes to SAME partition.

    Misuse causes severe performance degradation:
    - Writes to distributed log (batchlog)
    - Increases latency by 3-10x
    - Causes coordinator bottleneck
    - Reduces throughput

    Use UNLOGGED BATCH or async queries instead.
  base_severity: 9

  patterns:
    java:
      - pattern: 'BEGIN\s+BATCH'
        context: 'CQL LOGGED BATCH (default)'
      - pattern: 'BatchStatement\s*\('
        context: 'Java BatchStatement without UNLOGGED'

    python:
      - pattern: "execute\\([\"']BEGIN\\s+BATCH"
        context: 'Python CQL BATCH statement'
      - pattern: 'BatchStatement\('
        context: 'Python BatchStatement'

  fixes:
    description: |
      Use UNLOGGED BATCH or concurrent queries:

      // Bad - LOGGED BATCH for performance
      BEGIN BATCH
        INSERT INTO users (user_id, name) VALUES (1, 'Alice')
        INSERT INTO users (user_id, name) VALUES (2, 'Bob')
      APPLY BATCH

      // Good - UNLOGGED BATCH (no atomicity guarantee)
      BEGIN UNLOGGED BATCH
        INSERT INTO users (user_id, name) VALUES (1, 'Alice')
        INSERT INTO users (user_id, name) VALUES (2, 'Bob')
      APPLY BATCH

      // Better - Concurrent async queries
      await asyncio.gather(
          session.execute_async(insert_query, (1, 'Alice')),
          session.execute_async(insert_query, (2, 'Bob'))
      )

    references:
      - 'Batching in Cassandra: https://www.datastax.com/blog/atomic-batches-cassandra-12'

---

rule:
  id: CASSANDRA_TOMBSTONE_ACCUMULATION
  category: database
  name: Cassandra Tombstone Accumulation Risk
  description: |
    Frequent deletes or TTL expirations create tombstones.
    Too many tombstones cause read performance degradation and OOM errors.

    Problems:
    - Read queries scan tombstones
    - Causes ReadTimeout exceptions
    - Memory pressure on coordinator
    - Compaction overhead

    Monitor tombstone_warn_threshold (default 1000) and
    tombstone_failure_threshold (default 100000).
  base_severity: 8

  patterns:
    java:
      - pattern: 'DELETE\s+FROM\s+[a-zA-Z_]+.*WHERE'
        context: 'CQL DELETE statement'
      - pattern: 'TTL\s+\d+'
        context: 'CQL INSERT with TTL'
      - pattern: 'UPDATE.*USING\s+TTL'
        context: 'CQL UPDATE with TTL'

    python:
      - pattern: "execute\\([\"']DELETE\\s+FROM"
        context: 'Python CQL DELETE'
      - pattern: 'TTL\s+\d+'
        context: 'Python CQL with TTL'

  fixes:
    description: |
      Design for immutability and partition expiration:

      // Bad - Frequent deletes
      DELETE FROM sensor_data WHERE sensor_id = ? AND timestamp < ?

      // Good - Use time-bucketed tables with TTL
      CREATE TABLE sensor_data_2024_01 (
        sensor_id uuid,
        timestamp timestamp,
        value double,
        PRIMARY KEY ((sensor_id), timestamp)
      ) WITH default_time_to_live = 2592000  -- 30 days

      // Drop entire table when expired
      DROP TABLE sensor_data_2024_01

      Monitor tombstones:
      nodetool cfstats | grep "Tombstones"

    references:
      - 'Tombstone problem: https://thelastpickle.com/blog/2018/07/05/tombstones-in-apache-cassandra.html'
      - 'Time series data modeling: https://www.datastax.com/blog/advanced-time-series-cassandra'

---

rule:
  id: CASSANDRA_LARGE_PARTITION
  category: database
  name: Cassandra Large Partition Detection
  description: |
    Partitions larger than 100MB cause severe performance issues.
    Cassandra is designed for many small partitions, not few large ones.

    Problems:
    - Hot spots (uneven load distribution)
    - Slow reads and writes
    - Garbage collection pauses
    - Coordinator OOM
    - Difficult to repair/compact

    Recommended partition size: <100MB (max 400MB)
    Recommended cell count: <100K cells per partition
  base_severity: 9

  patterns:
    java:
      - pattern: 'PRIMARY\s+KEY\s*\(\s*\([a-zA-Z_]+\)\s*\)'
        context: 'CQL table with single partition key (potential large partition)'
      - pattern: 'INSERT\s+INTO.*VALUES.*(?!.*clustering)'
        context: 'CQL insert without clustering key'

  fixes:
    description: |
      Add clustering columns or bucket partition key:

      // Bad - Single partition key, unbounded growth
      CREATE TABLE user_events (
        user_id uuid PRIMARY KEY,
        events list<text>  -- This will grow indefinitely!
      )

      // Good - Add time-based clustering key
      CREATE TABLE user_events (
        user_id uuid,
        event_time timestamp,
        event_data text,
        PRIMARY KEY ((user_id), event_time)
      ) WITH CLUSTERING ORDER BY (event_time DESC)

      // Better - Bucket by time period
      CREATE TABLE user_events (
        user_id uuid,
        period text,  -- '2024-01', '2024-02', etc.
        event_time timestamp,
        event_data text,
        PRIMARY KEY ((user_id, period), event_time)
      )

      Monitor partition sizes:
      nodetool cfstats <keyspace>.<table>
      nodetool tablehistograms <keyspace> <table>

    references:
      - 'Partition sizing: https://www.datastax.com/blog/wide-partitions-apache-cassandra-33'
      - 'Data modeling guidelines: https://cassandra.apache.org/doc/latest/data_modeling/data_modeling_conceptual.html'

---

rule:
  id: CASSANDRA_CONSISTENCY_LEVEL_ABUSE
  category: database
  name: Cassandra Inappropriate Consistency Level
  description: |
    Using ALL or QUORUM consistency level unnecessarily
    sacrifices availability and performance.

    Problems with CL=ALL:
    - Single node failure breaks writes
    - High latency (waits for ALL replicas)
    - Reduced throughput

    Use LOCAL_QUORUM for most cases, ONE for high-throughput writes.
  base_severity: 7

  patterns:
    java:
      - pattern: 'ConsistencyLevel\.ALL'
        context: 'Java Cassandra driver CL=ALL'
      - pattern: 'setConsistencyLevel\(ConsistencyLevel\.ALL\)'
        context: 'Java setting CL=ALL'

    python:
      - pattern: 'consistency_level=ConsistencyLevel\.ALL'
        context: 'Python Cassandra driver CL=ALL'

    csharp:
      - pattern: 'ConsistencyLevel\.All'
        context: 'C# Cassandra driver CL=ALL'

  fixes:
    description: |
      Use appropriate consistency level:

      // Bad - CL=ALL (sacrifices availability)
      session.execute(query, consistency_level=ConsistencyLevel.ALL)

      // Good - CL=LOCAL_QUORUM (balance of consistency and availability)
      session.execute(query, consistency_level=ConsistencyLevel.LOCAL_QUORUM)

      // OK - CL=ONE for high-throughput, eventually consistent writes
      session.execute(query, consistency_level=ConsistencyLevel.ONE)

      Consistency level trade-offs:
      - ALL: Strong consistency, low availability (avoid)
      - QUORUM: Consistency across DCs (expensive)
      - LOCAL_QUORUM: Best for most use cases (recommended)
      - ONE: High throughput, eventual consistency

    references:
      - 'Consistency levels: https://docs.datastax.com/en/cassandra-oss/3.x/cassandra/dml/dmlConfigConsistency.html'
      - 'Tunable consistency: https://www.datastax.com/blog/how-data-written-distributed-database-cassandra'
