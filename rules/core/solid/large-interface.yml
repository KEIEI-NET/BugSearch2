# Large Interface ルール定義

rule:
  id: "SOLID_LARGE_INTERFACE"
  category: "solid"
  name: "Large Interface (Fat Interface)"
  description: "インターフェース分離原則（ISP）違反: 10メソッド以上の巨大インターフェースはクライアントに不要な依存を強制する"
  base_severity: 6

  # 言語ごとの検出パターン
  patterns:
    csharp:
      - pattern: 'interface\s+I\w+[^{]*\{[^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\('
        context: "Interface with 10+ method signatures"

    java:
      - pattern: 'interface\s+\w+[^{]*\{[^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\([^}]*\w+\s+\w+\s*\('
        context: "Interface with 10+ methods"

    typescript:
      - pattern: 'interface\s+\w+[^{]*\{[^}]*\w+\s*\([^}]*\w+\s*\([^}]*\w+\s*\([^}]*\w+\s*\([^}]*\w+\s*\([^}]*\w+\s*\([^}]*\w+\s*\([^}]*\w+\s*\([^}]*\w+\s*\([^}]*\w+\s*\('
        context: "Interface with 10+ method signatures"

      - pattern: 'interface\s+\w+[^{]*\{[^}]*\w+:\s*\w+[^}]*\w+:\s*\w+[^}]*\w+:\s*\w+[^}]*\w+:\s*\w+[^}]*\w+:\s*\w+[^}]*\w+:\s*\w+[^}]*\w+:\s*\w+[^}]*\w+:\s*\w+[^}]*\w+:\s*\w+[^}]*\w+:\s*\w+'
        context: "Interface with 10+ properties/methods"

    go:
      - pattern: 'type\s+\w+\s+interface\s*\{[^}]*\w+\s*\([^}]*\w+\s*\([^}]*\w+\s*\([^}]*\w+\s*\([^}]*\w+\s*\([^}]*\w+\s*\([^}]*\w+\s*\([^}]*\w+\s*\([^}]*\w+\s*\([^}]*\w+\s*\('
        context: "Interface with 10+ methods"

    php:
      - pattern: 'interface\s+\w+[^{]*\{[^}]*(public\s+)?function\s+\w+[^}]*(public\s+)?function\s+\w+[^}]*(public\s+)?function\s+\w+[^}]*(public\s+)?function\s+\w+[^}]*(public\s+)?function\s+\w+[^}]*(public\s+)?function\s+\w+[^}]*(public\s+)?function\s+\w+[^}]*(public\s+)?function\s+\w+[^}]*(public\s+)?function\s+\w+[^}]*(public\s+)?function\s+\w+'
        context: "Interface with 10+ methods"

  # 技術スタックによる深刻度調整
  context_modifiers:
    # リポジトリパターン（CRUD操作）
    - condition:
        code_context: 'Repository|IRepository|Dao|IDao'
      action:
        severity_adjustment: -3
        note: "リポジトリインターフェースは多数のCRUD操作を持つことがあります。ただし、汎用リポジトリは避け、エンティティ固有のリポジトリを推奨します。"

    # フレームワークの標準インターフェース
    - condition:
        code_context: 'IDisposable|IEnumerable|IComparable|Serializable'
      action:
        severity_adjustment: -5
        note: "フレームワークの標準インターフェースです。"

    # マーカーインターフェース（メソッドなし）
    - condition:
        code_context: 'interface\s+\w+[^{]*\{\s*\}'
      action:
        severity_adjustment: -6
        note: "マーカーインターフェース（メソッドなし）です。"

    # 自動生成インターフェース
    - condition:
        code_context: 'Generated|AutoGenerated|<auto-generated>'
      action:
        severity_adjustment: -4
        note: "自動生成インターフェースですが、設計を見直してください。"

    # テストモック用
    - condition:
        code_context: 'Mock|Stub|Fake|Test'
      action:
        severity_adjustment: -2
        note: "テスト用インターフェースですが、実装で使用しないよう注意してください。"

  # 技術スタック別の推奨修正方法
  fixes:
    default:
      - "インターフェースを責務ごとに分割"
      - "Role Interfaces: クライアントの役割ごとにインターフェースを定義"
      - "Interface Segregation: 1つの大きなインターフェースを複数の小さなインターフェースに分割"
      - "Facade Pattern: 複数のインターフェースへのシンプルなアクセスを提供"

    csharp:
      - "複数の小さなインターフェースに分割し、必要に応じて継承"
      - "Interface IUserReader { } / Interface IUserWriter { } のように読み取りと書き込みを分離"
      - "Default Interface Methods (C# 8.0+) で基本実装を提供（ただし慎重に）"

    java:
      - "単一責任のインターフェースに分割"
      - "Optional methods を避ける（UnsupportedOperationException を投げるメソッド）"
      - "Java 8+ の default methods は慎重に使用"

    typescript:
      - "複数の小さなインターフェースに分割"
      - "Type Intersection: type FullInterface = Interface1 & Interface2 & Interface3"
      - "Partial<T> で一部のプロパティのみ必須にする"

    go:
      - "小さなインターフェースに分割（Goの慣習: 1-3メソッド）"
      - "Interface embedding: type LargeInterface interface { Small1; Small2; Small3 }"
      - "クライアントが必要とする最小限のメソッドのみ定義"

    php:
      - "複数の小さなインターフェースに分割"
      - "必要に応じて複数のインターフェースを実装"
      - "Trait で共通実装を共有"

  # 分割の判断基準
  split_criteria:
    - "すべての実装クラスがすべてのメソッドを使用しない場合"
    - "一部のクライアントが一部のメソッドのみ使用する場合"
    - "インターフェース名に 'Manager' や 'Service' など曖昧な名前が含まれる場合"
    - "NotImplementedException をスローするメソッドがある場合"
    - "異なる責務（CRUD、検索、レポート生成など）が混在している場合"

  # 良い例と悪い例
  examples:
    bad_example:
      description: "すべてのCRUD操作を1つのインターフェースに含める"
      code: |
        interface IUserService {
          User GetById(int id);
          List<User> GetAll();
          User Create(User user);
          User Update(User user);
          void Delete(int id);
          List<User> Search(string query);
          void SendEmail(int userId);
          void ResetPassword(int userId);
          void ExportToExcel();
          void GenerateReport();
        }

    good_example:
      description: "責務ごとにインターフェースを分割"
      code: |
        interface IUserReader {
          User GetById(int id);
          List<User> Search(string query);
        }

        interface IUserWriter {
          User Create(User user);
          User Update(User user);
          void Delete(int id);
        }

        interface IUserNotifier {
          void SendEmail(int userId);
        }

        interface IUserReporter {
          void ExportToExcel();
          void GenerateReport();
        }

  # インターフェース分離の利点
  benefits:
    - "実装クラスが不要なメソッドを実装する必要がない"
    - "依存関係が明確になり、テストが容易"
    - "変更の影響範囲が限定される"
    - "クライアントが必要な機能のみに依存"

  # Go言語の慣習
  go_idioms:
    description: "Goでは小さなインターフェースが慣習"
    examples:
      - "io.Reader: 1メソッド (Read)"
      - "io.Writer: 1メソッド (Write)"
      - "io.Closer: 1メソッド (Close)"
      - "io.ReadWriteCloser: 上記3つを組み合わせ"

  # 追加情報
  references:
    - "https://en.wikipedia.org/wiki/Interface_segregation_principle"
    - "https://martinfowler.com/bliki/RoleInterface.html"
    - "https://golang.org/doc/effective_go#interfaces"
